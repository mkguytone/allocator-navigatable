<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>109.1. ポリモーフィックアロケーターの実装</title><link rel="stylesheet" type="text/css" href="index.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Linux で C/C++ の足固め： Linux の メモリー/ファイル/mmap と C++ アロケーター" /><link rel="up" href="ch109.html" title="第109章 std::pmr::polymorphic_allocator の動作チェック" /><link rel="prev" href="ch109.html" title="第109章 std::pmr::polymorphic_allocator の動作チェック" /><script xmlns="" type="text/javascript" src="prettify/prettify.js"></script><link xmlns="" rel="stylesheet" type="text/css" href="prettify/skins/sons-of-obsidian.css" /><script xmlns="">
    window.addEventListener("load", function() {
      PR.prettyPrint();
	  });	
	</script><script xmlns="" type="text/javascript" src="script/head.js"></script><html:meta xmlns:html="http://www.w3.org/1999/xhtml" name="viewport" content="width=320, initial-scale=1"></html:meta></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ch109.html">戻る</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> </td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_ポリモーフィックアロケーターの実装"></a>109.1. ポリモーフィックアロケーターの実装</h2></div></div></div><p>　memory_resource には std::pair に対しての処理が入っていなかったですね。</p><p>　おんや？　これで良いんだべ？</p><p>　とか疑問に思った読者もいるでしょう。</p><p>　はい、std::pair 引数の受付は memory_resource ではなく polymorphic_allocator によって、実装されています。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
uses_allocator.h
</li><li class="listitem">
memory_resource
</li></ul></div><p>　この 2 つのヘッダーが良くも悪くも、今の実装状況ということになるかと思います。</p><p><strong>uses_allocator.h (<a class="ulink" href="https://github.com/MacKomatsu/gcc/blob/master/libstdc%2B%2B-v3/include/bits/uses_allocator.h" target="_top">https://github.com/MacKomatsu/gcc/blob/master/libstdc%2B%2B-v3/include/bits/uses_allocator.h</a>). </strong>
</p><pre xmlns="" class="prettyprint"> 55   template&lt;typename _Tp, typename _Alloc, typename = __void_t&lt;&gt;&gt;
 56     struct __uses_allocator_helper
 57     : false_type { };
 58
 59   template&lt;typename _Tp, typename _Alloc&gt;
 60     struct __uses_allocator_helper&lt;_Tp, _Alloc,
 61            __void_t&lt;typename _Tp::allocator_type&gt;&gt;
 62     : __is_erased_or_convertible&lt;_Alloc, typename _Tp::allocator_type&gt;::type
 63     { };
 64
 65   /// [allocator.uses.trait]
 66   template&lt;typename _Tp, typename _Alloc&gt;
 67     struct uses_allocator
 68     : __uses_allocator_helper&lt;_Tp, _Alloc&gt;::type
 69     { };
 70
 71   struct __uses_alloc_base { };
 72
 73   struct __uses_alloc0 : __uses_alloc_base
 74   {
 75     struct _Sink { void operator=(const void*) { } } _M_a;
 76   };
 77
 78   template&lt;typename _Alloc&gt;
 79     struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };
 80
 81   template&lt;typename _Alloc&gt;
 82     struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };
 83
 84   template&lt;bool, typename _Tp, typename _Alloc, typename... _Args&gt;
 85     struct __uses_alloc;
 86
 87   template&lt;typename _Tp, typename _Alloc, typename... _Args&gt;
 88     struct __uses_alloc&lt;true, _Tp, _Alloc, _Args...&gt;
 89     : conditional&lt;
 90         is_constructible&lt;_Tp, allocator_arg_t, _Alloc, _Args...&gt;::value,
 91         __uses_alloc1&lt;_Alloc&gt;,
 92         __uses_alloc2&lt;_Alloc&gt;&gt;::type
 93     {
 94       static_assert(__or_&lt;
 95     is_constructible&lt;_Tp, allocator_arg_t, _Alloc, _Args...&gt;,
 96     is_constructible&lt;_Tp, _Args..., _Alloc&gt;&gt;::value, "construction with"
 97     " an allocator must be possible if uses_allocator is true");
 98     };
 99
100   template&lt;typename _Tp, typename _Alloc, typename... _Args&gt;
101     struct __uses_alloc&lt;false, _Tp, _Alloc, _Args...&gt;
102     : __uses_alloc0 { };
103
104   template&lt;typename _Tp, typename _Alloc, typename... _Args&gt;
105     using __uses_alloc_t =
106       __uses_alloc&lt;uses_allocator&lt;_Tp, _Alloc&gt;::value, _Tp, _Alloc, _Args...&gt;;
107
108   template&lt;typename _Tp, typename _Alloc, typename... _Args&gt;
109     inline __uses_alloc_t&lt;_Tp, _Alloc, _Args...&gt;
110     __use_alloc(const _Alloc&amp; __a)
111     {
112       __uses_alloc_t&lt;_Tp, _Alloc, _Args...&gt; __ret;
113       __ret._M_a = std::__addressof(__a);
114       return __ret;
115     }</pre><p>
</p><p>　ポリモーフィックアロケーターのソースコードは以下の通りです。</p><p><strong>polymorphic_allocator クラス (<a class="ulink" href="https://github.com/MacKomatsu/gcc/blob/master/libstdc%2B%2B-v3/include/experimental/memory_resource" target="_top">https://github.com/MacKomatsu/gcc/blob/master/libstdc%2B%2B-v3/include/experimental/memory_resource</a>). </strong>
</p><pre xmlns="" class="prettyprint">115   // 8.6 Class template polymorphic_allocator
116   template &lt;class _Tp&gt;
117     class polymorphic_allocator
118     {
119       using __uses_alloc1_ = __uses_alloc1&lt;memory_resource*&gt;;
120       using __uses_alloc2_ = __uses_alloc2&lt;memory_resource*&gt;;
121
122       template&lt;typename _Tp1, typename... _Args&gt;
123   void
124   _M_construct(__uses_alloc0, _Tp1* __p, _Args&amp;&amp;... __args)
125   { ::new(__p) _Tp1(std::forward&lt;_Args&gt;(__args)...); }
126
127       template&lt;typename _Tp1, typename... _Args&gt;
128   void
129   _M_construct(__uses_alloc1_, _Tp1* __p, _Args&amp;&amp;...  __args)
130   { ::new(__p) _Tp1(allocator_arg, this-&gt;resource(),
131         std::forward&lt;_Args&gt;(__args)...); }
132
133       template&lt;typename _Tp1, typename... _Args&gt;
134   void
135   _M_construct(__uses_alloc2_, _Tp1* __p, _Args&amp;&amp;...  __args)
136   { ::new(__p) _Tp1(std::forward&lt;_Args&gt;(__args)...,
137         this-&gt;resource()); }
138
139     public:
140       using value_type = _Tp;
141
142       polymorphic_allocator() noexcept
143       : _M_resource(get_default_resource())
144       { }
145
146       polymorphic_allocator(memory_resource* __r)
147       : _M_resource(__r)
148       { _GLIBCXX_DEBUG_ASSERT(__r); }
149
150       polymorphic_allocator(const polymorphic_allocator&amp; __other) = default;
151
152       template &lt;typename _Up&gt;
153   polymorphic_allocator(const polymorphic_allocator&lt;_Up&gt;&amp;
154             __other) noexcept
155   : _M_resource(__other.resource())
156   { }
157
158       polymorphic_allocator&amp;
159   operator=(const polymorphic_allocator&amp; __rhs) = default;
160
161       _Tp* allocate(size_t __n)
162       { return static_cast&lt;_Tp*&gt;(_M_resource-&gt;allocate(__n * sizeof(_Tp),
163                    alignof(_Tp))); }
164
165       void deallocate(_Tp* __p, size_t __n)
166       { _M_resource-&gt;deallocate(__p, __n * sizeof(_Tp), alignof(_Tp)); }
167
168       template &lt;typename _Tp1, typename... _Args&gt; //used here
169   void construct(_Tp1* __p, _Args&amp;&amp;... __args)
170   {
171     memory_resource* const __resource = this-&gt;resource();
172     auto __use_tag
173       = __use_alloc&lt;_Tp1, memory_resource*, _Args...&gt;(__resource);
174     _M_construct(__use_tag, __p, std::forward&lt;_Args&gt;(__args)...);
175   }
176
177       // Specializations for pair using piecewise construction
178       template &lt;typename _Tp1, typename _Tp2,
179          typename... _Args1, typename... _Args2&gt;
180   void construct(pair&lt;_Tp1, _Tp2&gt;* __p, piecewise_construct_t,
181            tuple&lt;_Args1...&gt; __x,
182            tuple&lt;_Args2...&gt; __y)
183   {
184     memory_resource* const __resource = this-&gt;resource();
185     auto __x_use_tag =
186       __use_alloc&lt;_Tp1, memory_resource*, _Args1...&gt;(__resource);
187     auto __y_use_tag =
188       __use_alloc&lt;_Tp2, memory_resource*, _Args2...&gt;(__resource);
189
190     ::new(__p) std::pair&lt;_Tp1, _Tp2&gt;(piecewise_construct,
191              _M_construct_p(__x_use_tag, __x),
192              _M_construct_p(__y_use_tag, __y));
193   }
194
195       template &lt;typename _Tp1, typename _Tp2&gt;
196   void construct(pair&lt;_Tp1,_Tp2&gt;* __p)
197   { this-&gt;construct(__p, piecewise_construct, tuple&lt;&gt;(), tuple&lt;&gt;()); }
198
199       template &lt;typename _Tp1, typename _Tp2, typename _Up, typename _Vp&gt;
200   void construct(pair&lt;_Tp1,_Tp2&gt;* __p, _Up&amp;&amp; __x, _Vp&amp;&amp; __y)
201   { this-&gt;construct(__p, piecewise_construct,
202         forward_as_tuple(std::forward&lt;_Up&gt;(__x)),
203         forward_as_tuple(std::forward&lt;_Vp&gt;(__y))); }
204
205       template &lt;typename _Tp1, typename _Tp2, typename _Up, typename _Vp&gt;
206   void construct(pair&lt;_Tp1,_Tp2&gt;* __p, const std::pair&lt;_Up, _Vp&gt;&amp; __pr)
207   { this-&gt;construct(__p, piecewise_construct, forward_as_tuple(__pr.first),
208         forward_as_tuple(__pr.second)); }
209
210       template &lt;typename _Tp1, typename _Tp2, typename _Up, typename _Vp&gt;
211   void construct(pair&lt;_Tp1,_Tp2&gt;* __p, pair&lt;_Up, _Vp&gt;&amp;&amp; __pr)
212   { this-&gt;construct(__p, piecewise_construct,
213         forward_as_tuple(std::forward&lt;_Up&gt;(__pr.first)),
214         forward_as_tuple(std::forward&lt;_Vp&gt;(__pr.second))); }
215
216       template &lt;typename _Up&gt;
217   void destroy(_Up* __p)
218   { __p-&gt;~_Up(); }
219
220       // Return a default-constructed allocator (no allocator propagation)
221       polymorphic_allocator select_on_container_copy_construction() const
222       { return polymorphic_allocator(); }
223
224       memory_resource* resource() const
225       { return _M_resource; }
226
227     private:
228       template&lt;typename _Tuple&gt;
229   _Tuple&amp;&amp;
230   _M_construct_p(__uses_alloc0, _Tuple&amp; __t)
231   { return std::move(__t); }
232
233       template&lt;typename... _Args&gt;
234   decltype(auto)
235   _M_construct_p(__uses_alloc1_ __ua, tuple&lt;_Args...&gt;&amp; __t)
236   { return tuple_cat(make_tuple(allocator_arg, *(__ua._M_a)),
237          std::move(__t)); }
238
239       template&lt;typename... _Args&gt;
240   decltype(auto)
241   _M_construct_p(__uses_alloc2_ __ua, tuple&lt;_Args...&gt;&amp; __t)
242   { return tuple_cat(std::move(__t), make_tuple(*(__ua._M_a))); }
243
244       memory_resource* _M_resource;
245     };</pre><p>
</p><p>　はーいはい、これまでの本書の蓄積があれば、ソースの分かりみが深いはずです。</p><p>　ですよね？</p><p>　std::pair 対策もきっちりやっていますし、筆者のサンプルコードと違って非の打ち所の無い完璧なコードです。</p><p>　他の pmr コンテナについては以下のような定義となると思いますが 2019 年の段階で使えるかは、まだ試していないので分かりませんね。</p><pre xmlns="" class="prettyprint">namespace pmr {
    template &lt;class T&gt;
    using list = std::list&lt;T, std::pmr::polymorphic_allocator&lt;T&gt;&gt;;
}

namespace pmr {
    template &lt;class Key, class T, class Compare = std::less&lt;Key&gt;&gt;
    using map = std::map&lt;Key, T, Compare,
                         std::pmr::polymorphic_allocator&lt;std::pair&lt;const Key,T&gt;&gt;&gt;
}

namespace pmr {
    template &lt;class Key, class Compare = std::less&lt;Key&gt;&gt;
    using multiset = std::multiset&lt;Key, Compare,
                                   std::pmr::polymorphic_allocator&lt;Key&gt;&gt;;
}

namespace pmr {
    template &lt;class Key, class Compare = std::less&lt;Key&gt;&gt;
    using set = std::set&lt;Key, Compare, std::pmr::polymorphic_allocator&lt;Key&gt;&gt;;
}

namespace pmr {
    template &lt;class Key,
              class T,
              class Hash = std::hash&lt;Key&gt;,
              class Pred = std::equal_to&lt;Key&gt;&gt;
    using unordered_map = std::unordered_map&lt;Key, T, Hash, Pred,
                              std::pmr::polymorphic_allocator&lt;std::pair&lt;const Key,T&gt;&gt;&gt;;
}

namespace pmr {
    template &lt;class Key, class T,
              class Hash = std::hash&lt;Key&gt;,
              class Pred = std::equal_to&lt;Key&gt;&gt;
    using unordered_multimap = std::unordered_multimap&lt;Key, T, Hash, Pred,
                                   std::pmr::polymorphic_allocator&lt;std::pair&lt;const Key,T&gt;&gt;&gt;;
}

namespace pmr {
    template &lt;class Key,
              class Hash = std::hash&lt;Key&gt;,
              class Pred = std::equal_to&lt;Key&gt;&gt;
    using unordered_set = std::unordered_set&lt;Key, Hash, Pred,
                                             std::pmr::polymorphic_allocator&lt;Key&gt;&gt;;
}

namespace pmr {
    template &lt;class Key,
              class Hash = std::hash&lt;Key&gt;,
              class Pred = std::equal_to&lt;Key&gt;&gt;
    using unordered_multiset = std::unordered_multiset&lt;Key, Hash, Pred,
                                   std::pmr::polymorphic_allocator&lt;Key&gt;&gt;
}</pre><p>　まだ実験的なものという理解なんで、これを使用しているコードを見る機会はあまり無いと思います。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch109.html">戻る</a> </td><td width="20%" align="center"><a accesskey="u" href="ch109.html">上に戻る</a></td><td width="40%" align="right"> </td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div><html>
<head>
<meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.2.0" />
<title></title>
</head>
<body>
<p>Copyright 2018-2019, by Masaki Komatsu</p>
<div class="toc">
<p><strong>目次</strong></p>
<dl class="toc">
<dt><span class="preface"><a href="pr01.html">序文</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="pr01s01.html">1. Linux
カーネルを学ぶ意義</a></span></dt>
<dt><span class="section"><a href="pr01s02.html">2. C++
カスタムアロケーターを作る意義</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch01.html">1.
対象となる読者</a></span></dt>
<dt><span class="chapter"><a href="ch02.html">2.
前提知識</a></span></dt>
<dt><span class="chapter"><a href="ch03.html">3.
開発環境</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch03s01.html">3.1. Linux
カーネルのバージョンを揃える</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt01.html">I. Linux と POSIX
C</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch04.html">4.
パイプとリダイレクトのまとめ</a></span></dt>
<dt><span class="chapter"><a href="ch05.html">5. echo
コマンド</a></span></dt>
<dt><span class="chapter"><a href="ch06.html">6.
シェルの確認</a></span></dt>
<dt><span class="chapter"><a href="ch07.html">7. /dev
ディレクトリー</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch07s01.html">7.1. echo
のリダイレクト</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch08.html">8.
アペンド</a></span></dt>
<dt><span class="chapter"><a href="ch09.html">9.
リダイレクトのファイル記述子</a></span></dt>
<dt><span class="chapter"><a href="ch10.html">10.
ファイル記述子間のリダイレクト</a></span></dt>
<dt><span class="chapter"><a href="ch11.html">11.
ファイル記述子リダイレクトのまとめ</a></span></dt>
<dt><span class="chapter"><a href="ch12.html">12. exec
(bash)</a></span></dt>
<dt><span class="chapter"><a href="ch13.html">13.
ファイル記述子を閉じる</a></span></dt>
<dt><span class="chapter"><a href="ch14.html">14.
読み書きファイル記述子</a></span></dt>
<dt><span class="chapter"><a href="ch15.html">15. /proc
ディレクトリー</a></span></dt>
<dt><span class="chapter"><a href="ch16.html">16. /dev/shm
ディレクトリー</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt02.html">II. Linux (POSIX)
のファイル入出力</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch17.html">17. system
関数</a></span></dt>
<dt><span class="chapter"><a href="ch18.html">18. fprintf
関数</a></span></dt>
<dt><span class="chapter"><a href="ch19.html">19. open / dprintf
関数</a></span></dt>
<dt><span class="chapter"><a href="ch20.html">20. read() / write()
関数</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch20s01.html">20.1.
文字列をヒープにコピー</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch21.html">21.
lseek()</a></span></dt>
<dt><span class="chapter"><a href="ch22.html">22. fopen / fread /
fwrite / fclose 関数</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt03.html">III. Linux
でメモリー割り当て</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch23.html">23. 32
ビットプロセスのレイアウト</a></span></dt>
<dt><span class="chapter"><a href="ch24.html">24. malloc
(cstdlib)</a></span></dt>
<dt><span class="chapter"><a href="ch25.html">25. malloc を strace
で検証してみる</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch25s01.html">25.1. ASLR
と共有オブジェクト</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch26.html">26. MALLOC(3) Linux
プログラマーマニュアル</a></span></dt>
<dt><span class="chapter"><a href="ch27.html">27. brk / sbrk
(unistd.h)</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch27s01.html">27.1. gdb で sbrk()
の解析</a></span></dt>
<dt><span class="section"><a href="ch27s02.html">27.2. strace によって
brk() / malloc() のコールをチェック</a></span></dt>
</dl>
</dd>
</dl>
</dd>
<dt><span class="part"><a href="pt04.html">IV. glibc から malloc()
の基本構造を理解してみる</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch28.html">28. malloc()
の内部実装</a></span></dt>
<dt><span class="chapter"><a href="ch29.html">29.
アリーナによるマルチスレッド対応</a></span></dt>
<dt><span class="chapter"><a href="ch30.html">30. アリーナオブジェクト（
main_arena / malloc_state ）</a></span></dt>
<dt><span class="chapter"><a href="ch31.html">31. ヒープのヘッダーオブジェクト（
heap_info )</a></span></dt>
<dt><span class="chapter"><a href="ch32.html">32. チャンク（
malloc_chunk ）</a></span></dt>
<dt><span class="chapter"><a href="ch33.html">33.
最少チャンクサイズと最少割り当てサイズ</a></span></dt>
<dt><span class="chapter"><a href="ch34.html">34.
malloc_par</a></span></dt>
<dt><span class="chapter"><a href="ch35.html">35. top
チャンク</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch35s01.html">35.1.
ビン</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch36.html">36. 未整理ビン / スモールビン /
ラージビン</a></span></dt>
<dt><span class="chapter"><a href="ch37.html">37.
ビンのインデックスの計算</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch37s01.html">37.1. 32
ビットアーキテクチャのビン</a></span></dt>
<dt><span class="section"><a href="ch37s02.html">37.2. 64
ビットアーキテクチャのビン</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch38.html">38.
ビン・インデックスのまとめ</a></span></dt>
<dt><span class="chapter"><a href="ch39.html">39.
ビンのチャンク連結</a></span></dt>
<dt><span class="chapter"><a href="ch40.html">40.
ビンの初期化</a></span></dt>
<dt><span class="chapter"><a href="ch41.html">41. 未整理チャンク（ Unsorted
Chunk ）のマクロ</a></span></dt>
<dt><span class="chapter"><a href="ch42.html">42. トップチャンク（ Top
Chunk ）のマクロ</a></span></dt>
<dt><span class="chapter"><a href="ch43.html">43. Binmap
のマクロ</a></span></dt>
<dt><span class="chapter"><a href="ch44.html">44.
tcache</a></span></dt>
<dt><span class="chapter"><a href="ch45.html">45. malloc()
フリーチャンクの挙動</a></span></dt>
<dt><span class="chapter"><a href="ch46.html">46. malloc.c
の内部マクロ</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch46s01.html">46.1.
チャンクを取り扱えるマクロ</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch47.html">47.
ファーストビンの解放</a></span></dt>
<dt><span class="chapter"><a href="ch48.html">48. malloc.c
の内部関数</a></span></dt>
<dt><span class="chapter"><a href="ch49.html">49. malloc()
の実装</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch49s01.html">49.1.
_int_malloc() 関数</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch50.html">50. free()
の実装</a></span></dt>
<dt><span class="chapter"><a href="ch51.html">51.
calloc()</a></span></dt>
<dt><span class="chapter"><a href="ch52.html">52.
realloc()</a></span></dt>
<dt><span class="chapter"><a href="ch53.html">53. alloca()
関数</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch53s01.html">53.1. alloca()
の使用法</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch54.html">54. posix_memalign()
/ aligned_alloc()</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch54s01.html">54.1. glibc-2.7
の内部実装</a></span></dt>
<dt><span class="section"><a href="ch54s02.html">54.2.
アラインメントの仕組み</a></span></dt>
<dt><span class="section"><a href="ch54s03.html">54.3.
アラインメントの最少サイズ</a></span></dt>
<dt><span class="section"><a href="ch54s04.html">54.4.
大きめのアラインメント</a></span></dt>
<dt><span class="section"><a href="ch54s05.html">54.5.
複数のアラインメントでの検証</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch55.html">55. std::launder (
C++17 )</a></span></dt>
<dt><span class="chapter"><a href="ch56.html">56.
std::aligned_storage ( C++11 )</a></span></dt>
<dt><span class="chapter"><a href="ch57.html">57. std::align (
C++11 )</a></span></dt>
<dt><span class="chapter"><a href="ch58.html">58.
std::aligned_alloc ( C++17 )</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt05.html">V. Linux
カーネルのメモリーとファイルシステム</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch59.html">59. Linux
の仮想メモリーエリア・メモリー記述子</a></span></dt>
<dt><span class="chapter"><a href="ch60.html">60. メモリー記述子（
mm_struct ）</a></span></dt>
<dt><span class="chapter"><a href="ch61.html">61. 仮想メモリー領域（
vm_area_struct ）</a></span></dt>
<dt><span class="chapter"><a href="ch62.html">62. ページ記述子（ struct
page ）</a></span></dt>
<dt><span class="chapter"><a href="ch63.html">63.
ページとブロック</a></span></dt>
<dt><span class="chapter"><a href="ch64.html">64. バッファー (
buffer_head )</a></span></dt>
<dt><span class="chapter"><a href="ch65.html">65. ブロック I/O ( bio
)</a></span></dt>
<dt><span class="chapter"><a href="ch66.html">66.
ページのキャッシュ</a></span></dt>
<dt><span class="chapter"><a href="ch67.html">67.
スラブレイヤー・スラブアロケーター</a></span></dt>
<dt><span class="chapter"><a href="ch68.html">68. ファイルとメモリーのマッピング
(mmap)</a></span></dt>
<dt><span class="chapter"><a href="ch69.html">69.
ページとハードウェア</a></span></dt>
<dt><span class="chapter"><a href="ch70.html">70. ページキャッシュ ( struct
address_space )</a></span></dt>
<dt><span class="chapter"><a href="ch71.html">71. Linux
のファイルシステム</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch71s01.html">71.1. カーネルヘッダー (
/usr/src/ )</a></span></dt>
<dt><span class="section"><a href="ch71s02.html">71.2.
カーネルソースのアーカイブ</a></span></dt>
<dt><span class="section"><a href="ch71s03.html">71.3. super_block
(カーネル)</a></span></dt>
<dt><span class="section"><a href="ch71s04.html">71.4. inode
(カーネル)</a></span></dt>
<dt><span class="section"><a href="ch71s05.html">71.5. dentry
(カーネル)</a></span></dt>
<dt><span class="section"><a href="ch71s06.html">71.6. file
(カーネル)</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch72.html">72. stat
構造体</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt06.html">VI. mmap</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch73.html">73. mmap
の使い方</a></span></dt>
<dt><span class="chapter"><a href="ch74.html">74.
マルチタスクで使えると共有メモリーオブジェクト</a></span></dt>
<dt><span class="chapter"><a href="ch75.html">75.
fork()</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch75s01.html">75.1. fork() を 2
回コールする</a></span></dt>
<dt><span class="section"><a href="ch75s02.html">75.2. fork() を 3
回コールする</a></span></dt>
<dt><span class="section"><a href="ch75s03.html">75.3. fork() を 4
回コールする</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch76.html">76. fstat
関数を使ってファイルサイズを指定する場合</a></span></dt>
<dt><span class="chapter"><a href="ch77.html">77. MAP_PRIVATE の
Copy-On-Write</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch77s01.html">77.1. fork() で
MAP_PRIVATE の Copy-On-Write を検証</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch78.html">78.
MAP_ANONYMOUS</a></span></dt>
<dt><span class="chapter"><a href="ch79.html">79.
アノニマスマッピング</a></span></dt>
<dt><span class="chapter"><a href="ch80.html">80. fork()
でプライベートファイルマッピングのチェック</a></span></dt>
<dt><span class="chapter"><a href="ch81.html">81. fork()
でプライベートアノニマスマッピングをチェック</a></span></dt>
<dt><span class="chapter"><a href="ch82.html">82. fork()
で共有ファイルマッピングをチェック</a></span></dt>
<dt><span class="chapter"><a href="ch83.html">83. fork()
で共有アノニマスマッピングをチェック</a></span></dt>
<dt><span class="chapter"><a href="ch84.html">84.
/dev/zero</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt07.html">VII.
（汎用ではない）カスタムアロケーターの設計</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch85.html">85.
アロケーターに必要な最低限の関数・オーバーロード・テンプレート</a></span></dt>
<dt><span class="chapter"><a href="ch86.html">86. std::allocator
を使うだけのリファレンスアロケーター</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch86s01.html">86.1.
std::allocator を模したカスタムアロケーター</a></span></dt>
</dl>
</dd>
</dl>
</dd>
<dt><span class="part"><a href="pt08.html">VIII.
スマートポインターで使えるデリーター</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch87.html">87.
スマートポインターの実装</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt09.html">IX.
スタック領域に割り当てるアロケーター</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch88.html">88.
配列内のアドレスの走査</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch88s01.html">88.1.
スタックアロケーター（可変長のリクエストサイズに対応、難易度高いのでスキップ推奨）</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch89.html">89.
ヒープへのフォールバック付きスタックアロケーター</a></span></dt>
<dt><span class="chapter"><a href="ch90.html">90.
コードをシンプルにする（内部バッファーのアドレスかのチェック）</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt10.html">X.
ヒープ領域のアドレスに割り当て</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch91.html">91.
ヒープ領域のアドレス</a></span></dt>
<dt><span class="chapter"><a href="ch92.html">92. malloc
を使ってヒープに割り当て</a></span></dt>
<dt><span class="chapter"><a href="ch93.html">93.
カスタムヒープアロケーター</a></span></dt>
<dt><span class="chapter"><a href="ch94.html">94. static
オブジェクトはヒープっぽい領域に割り当てられるはず？</a></span></dt>
<dt><span class="chapter"><a href="ch95.html">95.
アロケーターをスタティックメンバーにするとどうなるのか？</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt11.html">XI.
アロケーターをセレクターで切り替え</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch96.html">96.
アロケータークラス内での複数の割り当て方針を切り替え</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch96s01.html">96.1.
複数のアロケーターインスタンスを切り替え</a></span></dt>
</dl>
</dd>
</dl>
</dd>
<dt><span class="part"><a href="pt12.html">XII. C++ カスタムアロケーターの STL
サポート（実験）</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch97.html">97. C++
カスタムスタックアロケーターの用語の復習</a></span></dt>
<dt><span class="chapter"><a href="ch98.html">98. STL コンテナのサポート (
new / delete )</a></span></dt>
<dt><span class="chapter"><a href="ch99.html">99. STL
サポートの適用対象</a></span></dt>
<dt><span class="chapter"><a href="ch100.html">100. STL
コンテナ側のメモリー割り当て要件</a></span></dt>
<dt><span class="chapter"><a href="ch101.html">101. sizeof
を使った割り当てサイズの算出によるスタックアロケーター実装</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt13.html">XIII. mmap()
を使ったカスタムアロケーター</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch102.html">102.
ユーザーによるオブジェクト管理を前提にするカスタムページアロケーター</a></span></dt>
<dt><span class="chapter"><a href="ch103.html">103.
カスタムアロケーターによるブロック管理</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt14.html">XIV.
（おまけ）アロケーターのポリモーフィズム</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch104.html">104.
メモリーリソースクラス</a></span></dt>
<dt><span class="chapter"><a href="ch105.html">105.
std::experimental::pmr::memory_resource ( C++17 )</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch105s01.html">105.1.
memory_resource でアラインメントの実装（非実用的な実験です）</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch106.html">106.
ポリモーフィックアロケーター</a></span></dt>
<dt><span class="chapter"><a href="ch107.html">107.
std::pmr::polymorphic_allocator ( C++17 )</a></span></dt>
<dt><span class="chapter"><a href="ch108.html">108.
std::experimental::pmr::vector コンテナ ( C++17 )</a></span></dt>
<dt><span class="chapter"><a href="ch109.html">109.
std::pmr::polymorphic_allocator の動作チェック</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch109s01.html">109.1.
ポリモーフィックアロケーターの実装</a></span></dt>
</dl>
</dd>
</dl>
</dd>
</dl>
</div>
<div class="list-of-figures">
<p><strong>図の一覧</strong></p>
<dl>
<dt>30.1. <a href="ch30.html#idm1253">メインアリーナ（main_arena）</a></dt>
<dt>30.2. <a href="ch30.html#idm1266">スレッドアリーナ</a></dt>
<dt>32.1. <a href="ch32.html#idm1345">割り当て済みチャンク（allocated
chunk）</a></dt>
<dt>32.2. <a href="ch32.html#idm1372">割り当て済みチャンクの内部（allocated
chunk）</a></dt>
<dt>32.3. <a href="ch32.html#idm1382">フリーチャンク（free chunk）</a></dt>
<dt>32.4. <a href="ch32.html#idm1392">フリーチャンクの内部（small free
chunk、大きめでない場合）</a></dt>
<dt>39.1. <a href="ch39.html#idm2278">Unsorted/Small/Large
Bins</a></dt>
<dt>39.2. <a href="ch39.html#idm2306">Large Bins</a></dt>
<dt>68.1. <a href="ch68.html#idm3396">一段ページテーブル構成</a></dt>
<dt>68.2. <a href="ch68.html#idm3403">二段ページテーブル構成</a></dt>
<dt>68.3. <a href="ch68.html#idm3412">Linux 三段ページテーブル（Linux
2.6.11以前）</a></dt>
</dl>
</div>
<div class="list-of-tables">
<p><strong>表の一覧</strong></p>
<dl>
<dt>19.1. <a href="ch19.html#idm558">mode</a></dt>
<dt>35.1. <a href="ch35s01.html#idm1539">fastbin_index(sz)
の結果</a></dt>
<dt>37.1. <a href="ch37s01.html#idm1783">64 バイト間隔のインデックス</a></dt>
<dt>37.2. <a href="ch37s01.html#idm1838">512 バイト間隔のインデックス</a></dt>
<dt>37.3. <a href="ch37s01.html#idm1927">4096 バイト間隔のインデックス</a></dt>
<dt>37.4. <a href="ch37s01.html#idm1981">32768
バイト間隔のインデックス</a></dt>
<dt>37.5. <a href="ch37s01.html#idm2016">262144
バイト間隔のインデックス</a></dt>
<dt>73.1. <a href="ch73.html#idm3751">メモリー保護（ prot ）</a></dt>
</dl>
</div>
<p>Copyright 2018-2019, by Masaki Komatsu</p>
</body>
</html></body></html>