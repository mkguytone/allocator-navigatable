<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>37.2. 64 ビットアーキテクチャのビン</title><link rel="stylesheet" type="text/css" href="index.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Linux で C/C++ の足固め： Linux の メモリー/ファイル/mmap と C++ アロケーター" /><link rel="up" href="ch37.html" title="第37章 ビンのインデックスの計算" /><link rel="prev" href="ch37s01.html" title="37.1. 32 ビットアーキテクチャのビン" /><link rel="next" href="ch38.html" title="第38章 ビン・インデックスのまとめ" /><script xmlns="" type="text/javascript" src="prettify/prettify.js"></script><link xmlns="" rel="stylesheet" type="text/css" href="prettify/skins/sons-of-obsidian.css" /><script xmlns="">
    window.addEventListener("load", function() {
      PR.prettyPrint();
	  });	
	</script><script xmlns="" type="text/javascript" src="script/head.js"></script><html:meta xmlns:html="http://www.w3.org/1999/xhtml" name="viewport" content="width=320, initial-scale=1"></html:meta></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ch37s01.html">戻る</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch38.html">次へ</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_64_ビットアーキテクチャのビン"></a>37.2. 64 ビットアーキテクチャのビン</h2></div></div></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">注記</h3><p>largebin_index_32(sz) と largebin_index_64(sz) マクロは 64 バイト間隔のビンの処理を除くと同じコードになっています。したがってこの項目は 32 ビットの説明をスキップした方が読めば良いでしょう。</p></div><p>筆者の検証環境では 16 バイトアラインメント、64 ビットアーキテクチャなので largebin_index_64(sz) が該当します。</p><pre xmlns="" class="prettyprint">1492 #define largebin_index_64(sz)                                                \
1493   (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;&gt; 6) :\</pre><p>まずは 1493 行ですね…</p><p>smallbin_index(sz) によると 64 ビットアーキテクチャ、 16 バイトアラインメントは 1023 が上限なので、 Large bin は 1024 バイトが開始点になります。</p><p>つまり式を組み合わせると開始インデックスは 48 + (1024 &gt;&gt; 6) = 48 + 16 = 64 になります。</p><p>64 バイト間隔のビンの上限値は 64 * 48 = 3072 となります。</p><p>まあ以下のようになるでしょうね。</p><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /><col class="col_5" /><col class="col_6" /><col class="col_7" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">インデックス</th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">64  </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> 65 </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> 66 </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">   </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> 95 </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> (96)</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">ビンサイズ  </pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">1024-1087</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">1088-1151</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">1152-1215</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">...</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">3008-3071</pre></td><td style="" align="left" valign="top"><pre class="literallayout"> (3072)</pre></td></tr></tbody></table></div><p>64 バイト間隔のビンは 32 あるという想定だとインデックス 96 は 512 バイト間隔のビンと重なりそうな箇所ですが、1494 行でどのように扱われてるかチェックしましょう。</p><pre xmlns="" class="prettyprint">1494    ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;&gt; 9) :\</pre><p>512 バイトのビンの開始インデックスは 91 + (3073 &gt;&gt; 9) = 91 + 6 = 97 となります。</p><p>この解釈正しいんですかね…</p><p>(´・ω・｀)</p><p>何故迷うかというと 3072 のインデックスは 96 、次は 3073 のインデックスが 97 になるだけなので、64 バイトでなく 512 バイトのサイズに入れても問題ないですから…（喉からから）</p><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /><col class="col_5" /><col class="col_6" /><col class="col_7" /><col class="col_8" /><col class="col_9" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">インデックス</th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">(96)   </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">97  </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> 98 </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> 99 </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">   </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> 110                     </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> 111   </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> (112)</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">ビンサイズ  </pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">(3072) </pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">3073-3583</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">3584-4095</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">4096-4607</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">...</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">9728-10239</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout"> 10240 </pre></td><td style="" align="left" valign="top"><pre class="literallayout"> (10752)</pre></td></tr></tbody></table></div><p>512 バイト間隔のビンの開始点は 3073 なので 91 + (3072 &gt;&gt; 9) = 91 + 6 = 97 です。</p><p>つまり 96 は実質的には飛び地になるようです。</p><p>ちなみに上限値は 512 * 20 = 10240 となりますが、これだと 512 バイト間隔のビンの最後のインデックスは 111 となるべきのような気がします。</p><p>仕様だと 16 ビンあるはずでし、やはり 96 , …. , 111 が正しい範囲っぽそうです。</p><p>問題はインデックス 112 がどうなるかなので、次の条件式を見てみましょう。</p><pre xmlns="" class="prettyprint">1495    ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\</pre><p>これによると 10241-10752 は 4096 の倍数にならない値は端数となります。</p><p>110 + (10752 &gt;&gt; 12) = 110 + 2 = 112</p><p>次のインデックスは 4096 * 2 = 12282 になるまで動きがありません。</p><p>110 + (12288 &gt;&gt; 12) = 110 + 3 = 113</p><p>4096 バイト間隔のビンの開始は 10241 からなので 110 + (10241 &gt;&gt; 12) = 110 + 2 = 112 がインデックスになります。</p><p>さらに上限値は 4096 * 10 = 40960 となります。</p><p>そうすると 4096 バイト間隔のインデックス範囲は 112 , …, 119 または 113 , …, 120 になるはずです。</p><p>まあでも仕様に忠実とするなら 112, 113, …, 119 のほうが良さそうです。</p><p>たぶん以下のような感じになりますね。</p><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /><col class="col_5" /><col class="col_6" /><col class="col_7" /><col class="col_8" /><col class="col_9" /><col class="col_10" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">インデックス </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">112       </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> 113        </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">  114       </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">  115       </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">  116       </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">  117       </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">  118       </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> 119        </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> (120)</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">ビンの範囲  </pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">10241-12287</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout"> 12288-16383</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout"> 16384-20479</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout"> 20480-24575</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout"> 24576-28671</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout"> 28672-32767</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout"> 32768-36863</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout"> 36864-40959</pre></td><td style="" align="left" valign="top"><pre class="literallayout"> (40960)</pre></td></tr></tbody></table></div><p>念の為にインデックス 120 がどうなるのか次のビン（ 32768 バイト間隔）の条件式でチェックしてみましょう。</p><pre xmlns="" class="prettyprint">1496    ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\</pre><p>32768 バイト間隔のビンの開始インデックスは 119 + (40960 &gt;&gt; 15) = 119 + 1 = 120 と計算できます。</p><p>さらに上限値は 23768 * 4 = 131072 になります。</p><p>この情報から推測すると以下のようになるはずです。</p><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /><col class="col_5" /></colgroup><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">インデックス</pre></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">120         </pre></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">121           </pre></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">122            </pre></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">123</pre></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">ビンのサイズ</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">40960-73727 </pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout"> 73728-106495 </pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout"> 106496-131071 </pre></td><td style="" align="left" valign="top"><pre class="literallayout"> 131072</pre></td></tr></tbody></table></div><p>てことで 120, …, 123 が 32768 バイト間隔のインデックス範囲となるはずです。</p><p>もちろん計算が間違いでなければですが…　(´・ω・｀)</p><p>では 262144 バイト間隔のビンの条件式も見てみましょう。</p><pre xmlns="" class="prettyprint">1497    ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\
1498    126)</pre><p>262144 バイト間隔のビンの開始インデックスは 124 + ( 131072 &gt;&gt; 18 ) = 124 + 0 = 124 となりますね。</p><p>類推されるビンのインデックスは以下のような配置になるかと思います。</p><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">インデックス</pre></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">124           </pre></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">125            </pre></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout"> (126)</pre></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">ビンのサイズ</pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout">131072-262143 </pre></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><pre class="literallayout"> 262144-524287 </pre></td><td style="" align="left" valign="top"><pre class="literallayout"> 524288-</pre></td></tr></tbody></table></div><p>インデックス 126 は大きいのは何でもありって感じのビンですね。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch37s01.html">戻る</a> </td><td width="20%" align="center"><a accesskey="u" href="ch37.html">上に戻る</a></td><td width="40%" align="right"> <a accesskey="n" href="ch38.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div><wrapper xmlns=""><p>Copyright 2018-2019, by Masaki Komatsu</p>

<div class="toc"><p><strong>目次</strong></p><dl class="toc"><dt><span class="preface"><a href="pr01.html">序文</a></span></dt><dd><dl><dt><span class="section"><a href="pr01s01.html">1. Linux カーネルを学ぶ意義</a></span></dt><dt><span class="section"><a href="pr01s02.html">2. C++ カスタムアロケーターを作る意義</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch01.html">1. 対象となる読者</a></span></dt><dt><span class="chapter"><a href="ch02.html">2. 前提知識</a></span></dt><dt><span class="chapter"><a href="ch03.html">3. 開発環境</a></span></dt><dd><dl><dt><span class="section"><a href="ch03s01.html">3.1. Linux カーネルのバージョンを揃える</a></span></dt></dl></dd><dt><span class="part"><a href="pt01.html">I. Linux と POSIX C</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch04.html">4. パイプとリダイレクトのまとめ</a></span></dt><dt><span class="chapter"><a href="ch05.html">5. echo コマンド</a></span></dt><dt><span class="chapter"><a href="ch06.html">6. シェルの確認</a></span></dt><dt><span class="chapter"><a href="ch07.html">7. /dev ディレクトリー</a></span></dt><dd><dl><dt><span class="section"><a href="ch07s01.html">7.1. echo のリダイレクト</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch08.html">8. アペンド</a></span></dt><dt><span class="chapter"><a href="ch09.html">9. リダイレクトのファイル記述子</a></span></dt><dt><span class="chapter"><a href="ch10.html">10. ファイル記述子間のリダイレクト</a></span></dt><dt><span class="chapter"><a href="ch11.html">11. ファイル記述子リダイレクトのまとめ</a></span></dt><dt><span class="chapter"><a href="ch12.html">12. exec (bash)</a></span></dt><dt><span class="chapter"><a href="ch13.html">13. ファイル記述子を閉じる</a></span></dt><dt><span class="chapter"><a href="ch14.html">14. 読み書きファイル記述子</a></span></dt><dt><span class="chapter"><a href="ch15.html">15. /proc ディレクトリー</a></span></dt><dt><span class="chapter"><a href="ch16.html">16. /dev/shm ディレクトリー</a></span></dt></dl></dd><dt><span class="part"><a href="pt02.html">II. Linux (POSIX) のファイル入出力</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch17.html">17. system 関数</a></span></dt><dt><span class="chapter"><a href="ch18.html">18. fprintf 関数</a></span></dt><dt><span class="chapter"><a href="ch19.html">19. open / dprintf 関数</a></span></dt><dt><span class="chapter"><a href="ch20.html">20. read() / write() 関数</a></span></dt><dd><dl><dt><span class="section"><a href="ch20s01.html">20.1. 文字列をヒープにコピー</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch21.html">21. lseek()</a></span></dt><dt><span class="chapter"><a href="ch22.html">22. fopen / fread / fwrite / fclose 関数</a></span></dt></dl></dd><dt><span class="part"><a href="pt03.html">III. Linux でメモリー割り当て</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch23.html">23. 32 ビットプロセスのレイアウト</a></span></dt><dt><span class="chapter"><a href="ch24.html">24. malloc (cstdlib)</a></span></dt><dt><span class="chapter"><a href="ch25.html">25. malloc を strace で検証してみる</a></span></dt><dd><dl><dt><span class="section"><a href="ch25s01.html">25.1. ASLR と共有オブジェクト</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch26.html">26. MALLOC(3) Linux プログラマーマニュアル</a></span></dt><dt><span class="chapter"><a href="ch27.html">27. brk / sbrk (unistd.h)</a></span></dt><dd><dl><dt><span class="section"><a href="ch27s01.html">27.1. gdb で sbrk() の解析</a></span></dt><dt><span class="section"><a href="ch27s02.html">27.2. strace によって brk() / malloc() のコールをチェック</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="pt04.html">IV. glibc から malloc() の基本構造を理解してみる</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch28.html">28. malloc() の内部実装</a></span></dt><dt><span class="chapter"><a href="ch29.html">29. アリーナによるマルチスレッド対応</a></span></dt><dt><span class="chapter"><a href="ch30.html">30. アリーナオブジェクト（ main_arena / malloc_state ）</a></span></dt><dt><span class="chapter"><a href="ch31.html">31. ヒープのヘッダーオブジェクト（ heap_info )</a></span></dt><dt><span class="chapter"><a href="ch32.html">32. チャンク（ malloc_chunk ）</a></span></dt><dt><span class="chapter"><a href="ch33.html">33. 最少チャンクサイズと最少割り当てサイズ</a></span></dt><dt><span class="chapter"><a href="ch34.html">34. malloc_par</a></span></dt><dt><span class="chapter"><a href="ch35.html">35. top チャンク</a></span></dt><dd><dl><dt><span class="section"><a href="ch35s01.html">35.1. ビン</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch36.html">36. 未整理ビン / スモールビン / ラージビン</a></span></dt><dt><span class="chapter"><a href="ch37.html">37. ビンのインデックスの計算</a></span></dt><dd><dl><dt><span class="section"><a href="ch37s01.html">37.1. 32 ビットアーキテクチャのビン</a></span></dt><dt><span class="section"><a href="ch37s02.html">37.2. 64 ビットアーキテクチャのビン</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch38.html">38. ビン・インデックスのまとめ</a></span></dt><dt><span class="chapter"><a href="ch39.html">39. ビンのチャンク連結</a></span></dt><dt><span class="chapter"><a href="ch40.html">40. ビンの初期化</a></span></dt><dt><span class="chapter"><a href="ch41.html">41. 未整理チャンク（ Unsorted Chunk ）のマクロ</a></span></dt><dt><span class="chapter"><a href="ch42.html">42. トップチャンク（ Top Chunk ）のマクロ</a></span></dt><dt><span class="chapter"><a href="ch43.html">43. Binmap のマクロ</a></span></dt><dt><span class="chapter"><a href="ch44.html">44. tcache</a></span></dt><dt><span class="chapter"><a href="ch45.html">45. malloc() フリーチャンクの挙動</a></span></dt><dt><span class="chapter"><a href="ch46.html">46. malloc.c の内部マクロ</a></span></dt><dd><dl><dt><span class="section"><a href="ch46s01.html">46.1. チャンクを取り扱えるマクロ</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch47.html">47. ファーストビンの解放</a></span></dt><dt><span class="chapter"><a href="ch48.html">48. malloc.c の内部関数</a></span></dt><dt><span class="chapter"><a href="ch49.html">49. malloc() の実装</a></span></dt><dd><dl><dt><span class="section"><a href="ch49s01.html">49.1. _int_malloc() 関数</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch50.html">50. free() の実装</a></span></dt><dt><span class="chapter"><a href="ch51.html">51. calloc()</a></span></dt><dt><span class="chapter"><a href="ch52.html">52. realloc()</a></span></dt><dt><span class="chapter"><a href="ch53.html">53. alloca() 関数</a></span></dt><dd><dl><dt><span class="section"><a href="ch53s01.html">53.1. alloca() の使用法</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch54.html">54. posix_memalign() / aligned_alloc()</a></span></dt><dd><dl><dt><span class="section"><a href="ch54s01.html">54.1. glibc-2.7 の内部実装</a></span></dt><dt><span class="section"><a href="ch54s02.html">54.2. アラインメントの仕組み</a></span></dt><dt><span class="section"><a href="ch54s03.html">54.3. アラインメントの最少サイズ</a></span></dt><dt><span class="section"><a href="ch54s04.html">54.4. 大きめのアラインメント</a></span></dt><dt><span class="section"><a href="ch54s05.html">54.5. 複数のアラインメントでの検証</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch55.html">55. std::launder ( C++17 )</a></span></dt><dt><span class="chapter"><a href="ch56.html">56. std::aligned_storage ( C++11 )</a></span></dt><dt><span class="chapter"><a href="ch57.html">57. std::align ( C++11 )</a></span></dt><dt><span class="chapter"><a href="ch58.html">58. std::aligned_alloc ( C++17 )</a></span></dt></dl></dd><dt><span class="part"><a href="pt05.html">V. Linux カーネルのメモリーとファイルシステム</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch59.html">59. Linux の仮想メモリーエリア・メモリー記述子</a></span></dt><dt><span class="chapter"><a href="ch60.html">60. メモリー記述子（ mm_struct ）</a></span></dt><dt><span class="chapter"><a href="ch61.html">61. 仮想メモリー領域（ vm_area_struct ）</a></span></dt><dt><span class="chapter"><a href="ch62.html">62. ページ記述子（ struct page ）</a></span></dt><dt><span class="chapter"><a href="ch63.html">63. ページとブロック</a></span></dt><dt><span class="chapter"><a href="ch64.html">64. バッファー ( buffer_head )</a></span></dt><dt><span class="chapter"><a href="ch65.html">65. ブロック I/O ( bio )</a></span></dt><dt><span class="chapter"><a href="ch66.html">66. ページのキャッシュ</a></span></dt><dt><span class="chapter"><a href="ch67.html">67. スラブレイヤー・スラブアロケーター</a></span></dt><dt><span class="chapter"><a href="ch68.html">68. ファイルとメモリーのマッピング (mmap)</a></span></dt><dt><span class="chapter"><a href="ch69.html">69. ページとハードウェア</a></span></dt><dt><span class="chapter"><a href="ch70.html">70. ページキャッシュ ( struct address_space )</a></span></dt><dt><span class="chapter"><a href="ch71.html">71. Linux のファイルシステム</a></span></dt><dd><dl><dt><span class="section"><a href="ch71s01.html">71.1. カーネルヘッダー ( /usr/src/ )</a></span></dt><dt><span class="section"><a href="ch71s02.html">71.2. カーネルソースのアーカイブ</a></span></dt><dt><span class="section"><a href="ch71s03.html">71.3. super_block (カーネル)</a></span></dt><dt><span class="section"><a href="ch71s04.html">71.4. inode (カーネル)</a></span></dt><dt><span class="section"><a href="ch71s05.html">71.5. dentry (カーネル)</a></span></dt><dt><span class="section"><a href="ch71s06.html">71.6. file (カーネル)</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch72.html">72. stat 構造体</a></span></dt></dl></dd><dt><span class="part"><a href="pt06.html">VI. mmap</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch73.html">73. mmap の使い方</a></span></dt><dt><span class="chapter"><a href="ch74.html">74. マルチタスクで使えると共有メモリーオブジェクト</a></span></dt><dt><span class="chapter"><a href="ch75.html">75. fork()</a></span></dt><dd><dl><dt><span class="section"><a href="ch75s01.html">75.1. fork() を 2 回コールする</a></span></dt><dt><span class="section"><a href="ch75s02.html">75.2. fork() を 3 回コールする</a></span></dt><dt><span class="section"><a href="ch75s03.html">75.3. fork() を 4 回コールする</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch76.html">76. fstat 関数を使ってファイルサイズを指定する場合</a></span></dt><dt><span class="chapter"><a href="ch77.html">77. MAP_PRIVATE の Copy-On-Write</a></span></dt><dd><dl><dt><span class="section"><a href="ch77s01.html">77.1. fork() で MAP_PRIVATE の Copy-On-Write を検証</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch78.html">78. MAP_ANONYMOUS</a></span></dt><dt><span class="chapter"><a href="ch79.html">79. アノニマスマッピング</a></span></dt><dt><span class="chapter"><a href="ch80.html">80. fork() でプライベートファイルマッピングのチェック</a></span></dt><dt><span class="chapter"><a href="ch81.html">81. fork() でプライベートアノニマスマッピングをチェック</a></span></dt><dt><span class="chapter"><a href="ch82.html">82. fork() で共有ファイルマッピングをチェック</a></span></dt><dt><span class="chapter"><a href="ch83.html">83. fork() で共有アノニマスマッピングをチェック</a></span></dt><dt><span class="chapter"><a href="ch84.html">84. /dev/zero</a></span></dt></dl></dd><dt><span class="part"><a href="pt07.html">VII. （汎用ではない）カスタムアロケーターの設計</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch85.html">85. アロケーターに必要な最低限の関数・オーバーロード・テンプレート</a></span></dt><dt><span class="chapter"><a href="ch86.html">86. std::allocator を使うだけのリファレンスアロケーター</a></span></dt><dd><dl><dt><span class="section"><a href="ch86s01.html">86.1. std::allocator を模したカスタムアロケーター</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="pt08.html">VIII. スマートポインターで使えるデリーター</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch87.html">87. スマートポインターの実装</a></span></dt></dl></dd><dt><span class="part"><a href="pt09.html">IX. スタック領域に割り当てるアロケーター</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch88.html">88. 配列内のアドレスの走査</a></span></dt><dd><dl><dt><span class="section"><a href="ch88s01.html">88.1. スタックアロケーター（可変長のリクエストサイズに対応、難易度高いのでスキップ推奨）</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch89.html">89. ヒープへのフォールバック付きスタックアロケーター</a></span></dt><dt><span class="chapter"><a href="ch90.html">90. コードをシンプルにする（内部バッファーのアドレスかのチェック）</a></span></dt></dl></dd><dt><span class="part"><a href="pt10.html">X. ヒープ領域のアドレスに割り当て</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch91.html">91. ヒープ領域のアドレス</a></span></dt><dt><span class="chapter"><a href="ch92.html">92. malloc を使ってヒープに割り当て</a></span></dt><dt><span class="chapter"><a href="ch93.html">93. カスタムヒープアロケーター</a></span></dt><dt><span class="chapter"><a href="ch94.html">94. static オブジェクトはヒープっぽい領域に割り当てられるはず？</a></span></dt><dt><span class="chapter"><a href="ch95.html">95. アロケーターをスタティックメンバーにするとどうなるのか？</a></span></dt></dl></dd><dt><span class="part"><a href="pt11.html">XI. アロケーターをセレクターで切り替え</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch96.html">96. アロケータークラス内での複数の割り当て方針を切り替え</a></span></dt><dd><dl><dt><span class="section"><a href="ch96s01.html">96.1. 複数のアロケーターインスタンスを切り替え</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="pt12.html">XII. C++ カスタムアロケーターの STL サポート（実験）</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch97.html">97. C++ カスタムスタックアロケーターの用語の復習</a></span></dt><dt><span class="chapter"><a href="ch98.html">98. STL コンテナのサポート ( new / delete )</a></span></dt><dt><span class="chapter"><a href="ch99.html">99. STL サポートの適用対象</a></span></dt><dt><span class="chapter"><a href="ch100.html">100. STL コンテナ側のメモリー割り当て要件</a></span></dt><dt><span class="chapter"><a href="ch101.html">101. sizeof を使った割り当てサイズの算出によるスタックアロケーター実装</a></span></dt></dl></dd><dt><span class="part"><a href="pt13.html">XIII. mmap() を使ったカスタムアロケーター</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch102.html">102. ユーザーによるオブジェクト管理を前提にするカスタムページアロケーター</a></span></dt><dt><span class="chapter"><a href="ch103.html">103. カスタムアロケーターによるブロック管理</a></span></dt></dl></dd><dt><span class="part"><a href="pt14.html">XIV. （おまけ）アロケーターのポリモーフィズム</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch104.html">104. メモリーリソースクラス</a></span></dt><dt><span class="chapter"><a href="ch105.html">105. std::experimental::pmr::memory_resource ( C++17 )</a></span></dt><dd><dl><dt><span class="section"><a href="ch105s01.html">105.1. memory_resource でアラインメントの実装（非実用的な実験です）</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch106.html">106. ポリモーフィックアロケーター</a></span></dt><dt><span class="chapter"><a href="ch107.html">107. std::pmr::polymorphic_allocator ( C++17 )</a></span></dt><dt><span class="chapter"><a href="ch108.html">108. std::experimental::pmr::vector コンテナ ( C++17 )</a></span></dt><dt><span class="chapter"><a href="ch109.html">109. std::pmr::polymorphic_allocator の動作チェック</a></span></dt><dd><dl><dt><span class="section"><a href="ch109s01.html">109.1. ポリモーフィックアロケーターの実装</a></span></dt></dl></dd></dl></dd></dl></div><div class="list-of-figures"><p><strong>図の一覧</strong></p><dl><dt>30.1. <a href="ch30.html#idm1253">メインアリーナ（main_arena）</a></dt><dt>30.2. <a href="ch30.html#idm1266">スレッドアリーナ</a></dt><dt>32.1. <a href="ch32.html#idm1345">割り当て済みチャンク（allocated chunk）</a></dt><dt>32.2. <a href="ch32.html#idm1372">割り当て済みチャンクの内部（allocated chunk）</a></dt><dt>32.3. <a href="ch32.html#idm1382">フリーチャンク（free chunk）</a></dt><dt>32.4. <a href="ch32.html#idm1392">フリーチャンクの内部（small free chunk、大きめでない場合）</a></dt><dt>39.1. <a href="ch39.html#idm2278">Unsorted/Small/Large Bins</a></dt><dt>39.2. <a href="ch39.html#idm2306">Large Bins</a></dt><dt>68.1. <a href="ch68.html#idm3396">一段ページテーブル構成</a></dt><dt>68.2. <a href="ch68.html#idm3403">二段ページテーブル構成</a></dt><dt>68.3. <a href="ch68.html#idm3412">Linux 三段ページテーブル（Linux 2.6.11以前）</a></dt></dl></div><div class="list-of-tables"><p><strong>表の一覧</strong></p><dl><dt>19.1. <a href="ch19.html#idm558">mode</a></dt><dt>35.1. <a href="ch35s01.html#idm1539">fastbin_index(sz) の結果</a></dt><dt>37.1. <a href="ch37s01.html#idm1783">64 バイト間隔のインデックス</a></dt><dt>37.2. <a href="ch37s01.html#idm1838">512 バイト間隔のインデックス</a></dt><dt>37.3. <a href="ch37s01.html#idm1927">4096 バイト間隔のインデックス</a></dt><dt>37.4. <a href="ch37s01.html#idm1981">32768 バイト間隔のインデックス</a></dt><dt>37.5. <a href="ch37s01.html#idm2016">262144 バイト間隔のインデックス</a></dt><dt>73.1. <a href="ch73.html#idm3751">メモリー保護（ prot ）</a></dt></dl></div>

<p>Copyright 2018-2019, by Masaki Komatsu</p>
</wrapper></body></html>