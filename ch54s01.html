<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>54.1. glibc-2.7 の内部実装</title><link rel="stylesheet" type="text/css" href="index.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Linux で C/C++ の足固め： Linux の メモリー/ファイル/mmap と C++ アロケーター" /><link rel="up" href="ch54.html" title="第54章 posix_memalign() / aligned_alloc()" /><link rel="prev" href="ch54.html" title="第54章 posix_memalign() / aligned_alloc()" /><link rel="next" href="ch54s02.html" title="54.2. アラインメントの仕組み" /><script xmlns="" type="text/javascript" src="prettify/prettify.js"></script><link xmlns="" rel="stylesheet" type="text/css" href="prettify/skins/sons-of-obsidian.css" /><script xmlns="">
    window.addEventListener("load", function() {
      PR.prettyPrint();
	  });	
	</script><script xmlns="" type="text/javascript" src="script/head.js"></script><html:meta xmlns:html="http://www.w3.org/1999/xhtml" name="viewport" content="width=320, initial-scale=1"></html:meta></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ch54.html">戻る</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch54s02.html">次へ</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_glibc_2_7_の内部実装"></a>54.1. glibc-2.7 の内部実装</h2></div></div></div><p>　では glibc-2.7 の posix_memalign の内部実装を見てみましょう。</p><p><strong>__posix_memalign 関数（https://github.com/MacKomatsu/glibc/blob/release/2.27/master/malloc/malloc.c）. </strong>
</p><pre xmlns="" class="prettyprint">5354 /* We need a wrapper function for one of the additions of POSIX.  */
5355 int
5356 __posix_memalign (void **memptr, size_t alignment, size_t size)
5357 {
5358   void *mem;
5359
5360   /* Test whether the SIZE argument is valid.  It must be a power of
5361      two multiple of sizeof (void *).  */
5362   if (alignment % sizeof (void *) != 0
5363       || !powerof2 (alignment / sizeof (void *))
5364       || alignment == 0)
5365     return EINVAL;
5366
5367
5368   void *address = RETURN_ADDRESS (0);
5369   mem = _mid_memalign (alignment, size, address);
5370
5371   if (mem != NULL)
5372     {
5373       *memptr = mem;
5374       return 0;
5375     }
5376
5377   return ENOMEM;
5378 }
5379 weak_alias (__posix_memalign, posix_memalign)</pre><p>
</p><p>　__posix_memalign() がベースとなる関数ですが、この関数は _mid_memalign() 関数をコールしていますね。</p><pre xmlns="" class="prettyprint">5369   mem = _mid_memalign (alignment, size, address);</pre><p>　同様に alined_alloc() の実装も同様に _mid_memalign() 関数をコールします。</p><p><strong>__libc_memalign 関数（https://github.com/MacKomatsu/glibc/blob/release/2.27/master/malloc/malloc.c）. </strong>
</p><pre xmlns="" class="prettyprint">3252 void *
3253 __libc_memalign (size_t alignment, size_t bytes)
3254 {
3255   void *address = RETURN_ADDRESS (0);
3256   return _mid_memalign (alignment, bytes, address);
3257 }
//中略
3329 /* For ISO C11.  */
3330 weak_alias (__libc_memalign, aligned_alloc)
3331 libc_hidden_def (__libc_memalign)
//中略
5580 strong_alias (__libc_memalign, __memalign)
5581 weak_alias (__libc_memalign, memalign)</pre><p>
</p><p>　では _mid_memalign() 関数の実装です。</p><p><strong>_mid_memalign 関数（https://github.com/MacKomatsu/glibc/blob/release/2.27/master/malloc/malloc.c）. </strong>
</p><pre xmlns="" class="prettyprint">3259 static void *
3260 _mid_memalign (size_t alignment, size_t bytes, void *address)
3261 {
3262   mstate ar_ptr;
3263   void *p;
3264
3265   void *(*hook) (size_t, size_t, const void *) =
3266     atomic_forced_read (__memalign_hook);
3267   if (__builtin_expect (hook != NULL, 0))
3268     return (*hook)(alignment, bytes, address);
3269
3270   /* If we need less alignment than we give anyway, just relay to malloc.  */
3271   if (alignment &lt;= MALLOC_ALIGNMENT)
3272     return __libc_malloc (bytes);
3273
3274   /* Otherwise, ensure that it is at least a minimum chunk size */
3275   if (alignment &lt; MINSIZE)
3276     alignment = MINSIZE;
3277
3278   /* If the alignment is greater than SIZE_MAX / 2 + 1 it cannot be a
3279      power of 2 and will cause overflow in the check below.  */
3280   if (alignment &gt; SIZE_MAX / 2 + 1)
3281     {
3282       __set_errno (EINVAL);
3283       return 0;
3284     }
3285
3286   /* Check for overflow.  */
3287   if (bytes &gt; SIZE_MAX - alignment - MINSIZE)
3288     {
3289       __set_errno (ENOMEM);
3290       return 0;
3291     }
3292
3293
3294   /* Make sure alignment is power of 2.  */
3295   if (!powerof2 (alignment))
3296     {
3297       size_t a = MALLOC_ALIGNMENT * 2;
3298       while (a &lt; alignment)
3299         a &lt;&lt;= 1;
3300       alignment = a;
3301     }
3302
3303   if (SINGLE_THREAD_P)
3304     {
3305       p = _int_memalign (&amp;main_arena, alignment, bytes);
3306       assert (!p || chunk_is_mmapped (mem2chunk (p)) ||
3307         &amp;main_arena == arena_for_chunk (mem2chunk (p)));
3308
3309       return p;
3310     }
3311
3312   arena_get (ar_ptr, bytes + alignment + MINSIZE);
3313
3314   p = _int_memalign (ar_ptr, alignment, bytes);
3315   if (!p &amp;&amp; ar_ptr != NULL)
3316     {
3317       LIBC_PROBE (memory_memalign_retry, 2, bytes, alignment);
3318       ar_ptr = arena_get_retry (ar_ptr, bytes);
3319       p = _int_memalign (ar_ptr, alignment, bytes);
3320     }
3321
3322   if (ar_ptr != NULL)
3323     __libc_lock_unlock (ar_ptr-&gt;mutex);
3324
3325   assert (!p || chunk_is_mmapped (mem2chunk (p)) ||
3326           ar_ptr == arena_for_chunk (mem2chunk (p)));
3327   return p;
3328 }</pre><p>
</p><p>　この中で注目したいのは MALLOC_ALIGNMENT 以下のアラインメントサイズであれば __libc_malloc() で割り当てを行うということです。</p><pre xmlns="" class="prettyprint">3270   /* If we need less alignment than we give anyway, just relay to malloc.  */
3271   if (alignment &lt;= MALLOC_ALIGNMENT)
3272     return __libc_malloc (bytes);</pre><p>　この _mid_memalign() 関数は __libc_malloc() 関数をコールしてます。</p><p>　さらに _mid_memalign() 関数は _int_memalign() 関数もコールしてます。</p><pre xmlns="" class="prettyprint">3312   arena_get (ar_ptr, bytes + alignment + MINSIZE);
3313
3314   p = _int_memalign (ar_ptr, alignment, bytes);
3315   if (!p &amp;&amp; ar_ptr != NULL)
3316     {
3317       LIBC_PROBE (memory_memalign_retry, 2, bytes, alignment);
3318       ar_ptr = arena_get_retry (ar_ptr, bytes);
3319       p = _int_memalign (ar_ptr, alignment, bytes);
3320     }</pre><p>　リクエストされたアラインメントサイズが MALLOC_ALIGNMENT 以下の数値であれば __libc_malloc() 関数が呼び出され、そうでなければ代わりに _int_memalign() 関数がコールされるってな感じです。</p><p>　てなことで __libc_malloc() と _int_memalign() 関数の中身もチェックしてみましょう。</p><p><strong>__libc_malloc 関数（https://github.com/MacKomatsu/glibc/blob/release/2.27/master/malloc/malloc.c）. </strong>
</p><pre xmlns="" class="prettyprint">3026 void *
3027 __libc_malloc (size_t bytes)
3028 {
3029   mstate ar_ptr;
3030   void *victim;
3031
3032   void *(*hook) (size_t, const void *)
3033     = atomic_forced_read (__malloc_hook);
3034   if (__builtin_expect (hook != NULL, 0))
3035     return (*hook)(bytes, RETURN_ADDRESS (0));
3036 #if USE_TCACHE
3037   /* int_free also calls request2size, be careful to not pad twice.  */
3038   size_t tbytes;
3039   checked_request2size (bytes, tbytes);
3040   size_t tc_idx = csize2tidx (tbytes);
3041
3042   MAYBE_INIT_TCACHE ();
3043
3044   DIAG_PUSH_NEEDS_COMMENT;
3045   if (tc_idx &lt; mp_.tcache_bins
3046       /*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/ /* to appease gcc */
3047       &amp;&amp; tcache
3048       &amp;&amp; tcache-&gt;entries[tc_idx] != NULL)
3049     {
3050       return tcache_get (tc_idx);
3051     }
3052   DIAG_POP_NEEDS_COMMENT;
3053 #endif
3054
3055   if (SINGLE_THREAD_P)
3056     {
3057       victim = _int_malloc (&amp;main_arena, bytes);
3058       assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||
3059         &amp;main_arena == arena_for_chunk (mem2chunk (victim)));
3060       return victim;
3061     }
3062
3063   arena_get (ar_ptr, bytes);
3064
3065   victim = _int_malloc (ar_ptr, bytes);
3066   /* Retry with another arena only if we were able to find a usable arena
3067      before.  */
3068   if (!victim &amp;&amp; ar_ptr != NULL)
3069     {
3070       LIBC_PROBE (memory_malloc_retry, 1, bytes);
3071       ar_ptr = arena_get_retry (ar_ptr, bytes);
3072       victim = _int_malloc (ar_ptr, bytes);
3073     }
3074
3075   if (ar_ptr != NULL)
3076     __libc_lock_unlock (ar_ptr-&gt;mutex);
3077
3078   assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||
3079           ar_ptr == arena_for_chunk (mem2chunk (victim)));
3080   return victim;
3081 }</pre><p>
</p><p>　__libc_malloc() 関数は _int_malloc() 関数をコールしてますね。</p><pre xmlns="" class="prettyprint">3063   arena_get (ar_ptr, bytes);
3064
3065   victim = _int_malloc (ar_ptr, bytes);
3066   /* Retry with another arena only if we were able to find a usable arena
3067      before.  */
3068   if (!victim &amp;&amp; ar_ptr != NULL)
3069     {
3070       LIBC_PROBE (memory_malloc_retry, 1, bytes);
3071       ar_ptr = arena_get_retry (ar_ptr, bytes);
3072       victim = _int_malloc (ar_ptr, bytes);
3073     }</pre><p>　_int_malloc() 関数の宣言は以下のようになっています。</p><pre xmlns="" class="prettyprint">static void*  _int_malloc(mstate, size_t);</pre><p>　この __libc_malloc() と _int_malloc() 関数は malloc の内部実装に該当します。</p><p>　つまりリクエストされたアラインメントサイズが MALLOC_ALIGNMENT 以下の数値であればデフォルトのアラインメントが適用されます。</p><p>　筆者の開発環境では 16 バイト境界がデフォルトになります。</p><p>　そして _int_memalign() も同様に _int_malloc() 関数をコールします。</p><p><strong>_int_memalign 関数（https://github.com/MacKomatsu/glibc/blob/release/2.27/master/malloc/malloc.c）. </strong>
</p><pre xmlns="" class="prettyprint">4661 static void *
4662 _int_memalign (mstate av, size_t alignment, size_t bytes)
4663 {
4664   INTERNAL_SIZE_T nb;             /* padded  request size */
4665   char *m;                        /* memory returned by malloc call */
4666   mchunkptr p;                    /* corresponding chunk */
4667   char *brk;                      /* alignment point within p */
4668   mchunkptr newp;                 /* chunk to return */
4669   INTERNAL_SIZE_T newsize;        /* its size */
4670   INTERNAL_SIZE_T leadsize;       /* leading space before alignment point */
4671   mchunkptr remainder;            /* spare room at end to split off */
4672   unsigned long remainder_size;   /* its size */
4673   INTERNAL_SIZE_T size;
4674
4675
4676
4677   checked_request2size (bytes, nb);
4678
4679   /*
4680      Strategy: find a spot within that chunk that meets the alignment
4681      request, and then possibly free the leading and trailing space.
4682    */
4683
4684
4685   /* Check for overflow.  */
4686   if (nb &gt; SIZE_MAX - alignment - MINSIZE)
4687     {
4688       __set_errno (ENOMEM);
4689       return 0;
4690     }
4691
4692   /* Call malloc with worst case padding to hit alignment. */
4693
4694   m = (char *) (_int_malloc (av, nb + alignment + MINSIZE));
4695
4696   if (m == 0)
4697     return 0;           /* propagate failure */
4698
4699   p = mem2chunk (m);
4700
4701   if ((((unsigned long) (m)) % alignment) != 0)   /* misaligned */
4702
4703     { /*
4704                 Find an aligned spot inside chunk.  Since we need to give back
4705                 leading space in a chunk of at least MINSIZE, if the first
4706                 calculation places us at a spot with less than MINSIZE leader,
4707                 we can move to the next aligned spot -- we've allocated enough
4708                 total room so that this is always possible.
4709                  */
4710       brk = (char *) mem2chunk (((unsigned long) (m + alignment - 1)) &amp;
4711                                 - ((signed long) alignment));
4712       if ((unsigned long) (brk - (char *) (p)) &lt; MINSIZE)
4713         brk += alignment;
4714
4715       newp = (mchunkptr) brk;
4716       leadsize = brk - (char *) (p);
4717       newsize = chunksize (p) - leadsize;
4718
4719       /* For mmapped chunks, just adjust offset */
4720       if (chunk_is_mmapped (p))
4721         {
4722           set_prev_size (newp, prev_size (p) + leadsize);
4723           set_head (newp, newsize | IS_MMAPPED);
4724           return chunk2mem (newp);
4725         }
4726
4727       /* Otherwise, give back leader, use the rest */
4728       set_head (newp, newsize | PREV_INUSE |
4729                 (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
4730       set_inuse_bit_at_offset (newp, newsize);
4731       set_head_size (p, leadsize | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
4732       _int_free (av, p, 1);
4733       p = newp;
4734
4735       assert (newsize &gt;= nb &amp;&amp;
4736               (((unsigned long) (chunk2mem (p))) % alignment) == 0);
4737     }
4738
4739   /* Also give back spare room at the end */
4740   if (!chunk_is_mmapped (p))
4741     {
4742       size = chunksize (p);
4743       if ((unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))
4744         {
4745           remainder_size = size - nb;
4746           remainder = chunk_at_offset (p, nb);
4747           set_head (remainder, remainder_size | PREV_INUSE |
4748                     (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
4749           set_head_size (p, nb);
4750           _int_free (av, remainder, 1);
4751         }
4752     }
4753
4754   check_inuse_chunk (av, p);
4755   return chunk2mem (p);
4756 }</pre><p>
</p><p>　この中で注目したいのはメモリーの割り当て時に、パディングされたバイトサイズとなる nb に対してアラインメントと MINSIZE が追加されることです。</p><pre xmlns="" class="prettyprint">4692   /* Call malloc with worst case padding to hit alignment. */
4693
4694   m = (char *) (_int_malloc (av, nb + alignment + MINSIZE));</pre><p>　アラインメントは MINSIZE を加算することで可能になるのが分かると思います。</p><p>　MINSIZE については以下のように計算されます。</p><p><strong><a class="ulink" href="https://github.com/MacKomatsu/glibc/blob/release/2.27/master/malloc/malloc.c" target="_top">https://github.com/MacKomatsu/glibc/blob/release/2.27/master/malloc/malloc.c</a>. </strong>
</p><pre xmlns="" class="prettyprint">1190 /* The smallest possible chunk */
1191 #define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))
1192
1193 /* The smallest size we can malloc is an aligned minimal chunk */
1194
1195 #define MINSIZE  \
1196   (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</pre><p>
</p><p>　MIN_CHUNK_SIZE は struct malloc_chunk 構造体のメンバー fd_nextsize までのオフセットバイトを取得したものです。</p><p>　参考までに以下が malloc_chunk の定義となります。</p><p><strong><a class="ulink" href="https://github.com/MacKomatsu/glibc/blob/release/2.27/master/malloc/malloc.c" target="_top">https://github.com/MacKomatsu/glibc/blob/release/2.27/master/malloc/malloc.c</a>. </strong>
</p><pre xmlns="" class="prettyprint">1060 struct malloc_chunk {
1061
1062   INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */
1063   INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
1064
1065   struct malloc_chunk* fd;         /* double links -- used only if free. */
1066   struct malloc_chunk* bk;
1067
1068   /* Only used for large blocks: pointer to next larger size.  */
1069   struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
1070   struct malloc_chunk* bk_nextsize;
1071 };</pre><p>
</p><p>　MINSIZE マクロは分かりにくいので、簡単なアラインメントをするコードを次の項目で考えて見ましょう。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch54.html">戻る</a> </td><td width="20%" align="center"><a accesskey="u" href="ch54.html">上に戻る</a></td><td width="40%" align="right"> <a accesskey="n" href="ch54s02.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div><html>
<head>
<meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.2.0" />
<title></title>
</head>
<body>
<p>Copyright 2018-2019, by Masaki Komatsu</p>
<div class="toc">
<p><strong>目次</strong></p>
<dl class="toc">
<dt><span class="preface"><a href="pr01.html">序文</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="pr01s01.html">1. Linux
カーネルを学ぶ意義</a></span></dt>
<dt><span class="section"><a href="pr01s02.html">2. C++
カスタムアロケーターを作る意義</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch01.html">1.
対象となる読者</a></span></dt>
<dt><span class="chapter"><a href="ch02.html">2.
前提知識</a></span></dt>
<dt><span class="chapter"><a href="ch03.html">3.
開発環境</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch03s01.html">3.1. Linux
カーネルのバージョンを揃える</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt01.html">I. Linux と POSIX
C</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch04.html">4.
パイプとリダイレクトのまとめ</a></span></dt>
<dt><span class="chapter"><a href="ch05.html">5. echo
コマンド</a></span></dt>
<dt><span class="chapter"><a href="ch06.html">6.
シェルの確認</a></span></dt>
<dt><span class="chapter"><a href="ch07.html">7. /dev
ディレクトリー</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch07s01.html">7.1. echo
のリダイレクト</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch08.html">8.
アペンド</a></span></dt>
<dt><span class="chapter"><a href="ch09.html">9.
リダイレクトのファイル記述子</a></span></dt>
<dt><span class="chapter"><a href="ch10.html">10.
ファイル記述子間のリダイレクト</a></span></dt>
<dt><span class="chapter"><a href="ch11.html">11.
ファイル記述子リダイレクトのまとめ</a></span></dt>
<dt><span class="chapter"><a href="ch12.html">12. exec
(bash)</a></span></dt>
<dt><span class="chapter"><a href="ch13.html">13.
ファイル記述子を閉じる</a></span></dt>
<dt><span class="chapter"><a href="ch14.html">14.
読み書きファイル記述子</a></span></dt>
<dt><span class="chapter"><a href="ch15.html">15. /proc
ディレクトリー</a></span></dt>
<dt><span class="chapter"><a href="ch16.html">16. /dev/shm
ディレクトリー</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt02.html">II. Linux (POSIX)
のファイル入出力</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch17.html">17. system
関数</a></span></dt>
<dt><span class="chapter"><a href="ch18.html">18. fprintf
関数</a></span></dt>
<dt><span class="chapter"><a href="ch19.html">19. open / dprintf
関数</a></span></dt>
<dt><span class="chapter"><a href="ch20.html">20. read() / write()
関数</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch20s01.html">20.1.
文字列をヒープにコピー</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch21.html">21.
lseek()</a></span></dt>
<dt><span class="chapter"><a href="ch22.html">22. fopen / fread /
fwrite / fclose 関数</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt03.html">III. Linux
でメモリー割り当て</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch23.html">23. 32
ビットプロセスのレイアウト</a></span></dt>
<dt><span class="chapter"><a href="ch24.html">24. malloc
(cstdlib)</a></span></dt>
<dt><span class="chapter"><a href="ch25.html">25. malloc を strace
で検証してみる</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch25s01.html">25.1. ASLR
と共有オブジェクト</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch26.html">26. MALLOC(3) Linux
プログラマーマニュアル</a></span></dt>
<dt><span class="chapter"><a href="ch27.html">27. brk / sbrk
(unistd.h)</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch27s01.html">27.1. gdb で sbrk()
の解析</a></span></dt>
<dt><span class="section"><a href="ch27s02.html">27.2. strace によって
brk() / malloc() のコールをチェック</a></span></dt>
</dl>
</dd>
</dl>
</dd>
<dt><span class="part"><a href="pt04.html">IV. glibc から malloc()
の基本構造を理解してみる</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch28.html">28. malloc()
の内部実装</a></span></dt>
<dt><span class="chapter"><a href="ch29.html">29.
アリーナによるマルチスレッド対応</a></span></dt>
<dt><span class="chapter"><a href="ch30.html">30. アリーナオブジェクト（
main_arena / malloc_state ）</a></span></dt>
<dt><span class="chapter"><a href="ch31.html">31. ヒープのヘッダーオブジェクト（
heap_info )</a></span></dt>
<dt><span class="chapter"><a href="ch32.html">32. チャンク（
malloc_chunk ）</a></span></dt>
<dt><span class="chapter"><a href="ch33.html">33.
最少チャンクサイズと最少割り当てサイズ</a></span></dt>
<dt><span class="chapter"><a href="ch34.html">34.
malloc_par</a></span></dt>
<dt><span class="chapter"><a href="ch35.html">35. top
チャンク</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch35s01.html">35.1.
ビン</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch36.html">36. 未整理ビン / スモールビン /
ラージビン</a></span></dt>
<dt><span class="chapter"><a href="ch37.html">37.
ビンのインデックスの計算</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch37s01.html">37.1. 32
ビットアーキテクチャのビン</a></span></dt>
<dt><span class="section"><a href="ch37s02.html">37.2. 64
ビットアーキテクチャのビン</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch38.html">38.
ビン・インデックスのまとめ</a></span></dt>
<dt><span class="chapter"><a href="ch39.html">39.
ビンのチャンク連結</a></span></dt>
<dt><span class="chapter"><a href="ch40.html">40.
ビンの初期化</a></span></dt>
<dt><span class="chapter"><a href="ch41.html">41. 未整理チャンク（ Unsorted
Chunk ）のマクロ</a></span></dt>
<dt><span class="chapter"><a href="ch42.html">42. トップチャンク（ Top
Chunk ）のマクロ</a></span></dt>
<dt><span class="chapter"><a href="ch43.html">43. Binmap
のマクロ</a></span></dt>
<dt><span class="chapter"><a href="ch44.html">44.
tcache</a></span></dt>
<dt><span class="chapter"><a href="ch45.html">45. malloc()
フリーチャンクの挙動</a></span></dt>
<dt><span class="chapter"><a href="ch46.html">46. malloc.c
の内部マクロ</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch46s01.html">46.1.
チャンクを取り扱えるマクロ</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch47.html">47.
ファーストビンの解放</a></span></dt>
<dt><span class="chapter"><a href="ch48.html">48. malloc.c
の内部関数</a></span></dt>
<dt><span class="chapter"><a href="ch49.html">49. malloc()
の実装</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch49s01.html">49.1.
_int_malloc() 関数</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch50.html">50. free()
の実装</a></span></dt>
<dt><span class="chapter"><a href="ch51.html">51.
calloc()</a></span></dt>
<dt><span class="chapter"><a href="ch52.html">52.
realloc()</a></span></dt>
<dt><span class="chapter"><a href="ch53.html">53. alloca()
関数</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch53s01.html">53.1. alloca()
の使用法</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch54.html">54. posix_memalign()
/ aligned_alloc()</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch54s01.html">54.1. glibc-2.7
の内部実装</a></span></dt>
<dt><span class="section"><a href="ch54s02.html">54.2.
アラインメントの仕組み</a></span></dt>
<dt><span class="section"><a href="ch54s03.html">54.3.
アラインメントの最少サイズ</a></span></dt>
<dt><span class="section"><a href="ch54s04.html">54.4.
大きめのアラインメント</a></span></dt>
<dt><span class="section"><a href="ch54s05.html">54.5.
複数のアラインメントでの検証</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch55.html">55. std::launder (
C++17 )</a></span></dt>
<dt><span class="chapter"><a href="ch56.html">56.
std::aligned_storage ( C++11 )</a></span></dt>
<dt><span class="chapter"><a href="ch57.html">57. std::align (
C++11 )</a></span></dt>
<dt><span class="chapter"><a href="ch58.html">58.
std::aligned_alloc ( C++17 )</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt05.html">V. Linux
カーネルのメモリーとファイルシステム</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch59.html">59. Linux
の仮想メモリーエリア・メモリー記述子</a></span></dt>
<dt><span class="chapter"><a href="ch60.html">60. メモリー記述子（
mm_struct ）</a></span></dt>
<dt><span class="chapter"><a href="ch61.html">61. 仮想メモリー領域（
vm_area_struct ）</a></span></dt>
<dt><span class="chapter"><a href="ch62.html">62. ページ記述子（ struct
page ）</a></span></dt>
<dt><span class="chapter"><a href="ch63.html">63.
ページとブロック</a></span></dt>
<dt><span class="chapter"><a href="ch64.html">64. バッファー (
buffer_head )</a></span></dt>
<dt><span class="chapter"><a href="ch65.html">65. ブロック I/O ( bio
)</a></span></dt>
<dt><span class="chapter"><a href="ch66.html">66.
ページのキャッシュ</a></span></dt>
<dt><span class="chapter"><a href="ch67.html">67.
スラブレイヤー・スラブアロケーター</a></span></dt>
<dt><span class="chapter"><a href="ch68.html">68. ファイルとメモリーのマッピング
(mmap)</a></span></dt>
<dt><span class="chapter"><a href="ch69.html">69.
ページとハードウェア</a></span></dt>
<dt><span class="chapter"><a href="ch70.html">70. ページキャッシュ ( struct
address_space )</a></span></dt>
<dt><span class="chapter"><a href="ch71.html">71. Linux
のファイルシステム</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch71s01.html">71.1. カーネルヘッダー (
/usr/src/ )</a></span></dt>
<dt><span class="section"><a href="ch71s02.html">71.2.
カーネルソースのアーカイブ</a></span></dt>
<dt><span class="section"><a href="ch71s03.html">71.3. super_block
(カーネル)</a></span></dt>
<dt><span class="section"><a href="ch71s04.html">71.4. inode
(カーネル)</a></span></dt>
<dt><span class="section"><a href="ch71s05.html">71.5. dentry
(カーネル)</a></span></dt>
<dt><span class="section"><a href="ch71s06.html">71.6. file
(カーネル)</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch72.html">72. stat
構造体</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt06.html">VI. mmap</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch73.html">73. mmap
の使い方</a></span></dt>
<dt><span class="chapter"><a href="ch74.html">74.
マルチタスクで使えると共有メモリーオブジェクト</a></span></dt>
<dt><span class="chapter"><a href="ch75.html">75.
fork()</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch75s01.html">75.1. fork() を 2
回コールする</a></span></dt>
<dt><span class="section"><a href="ch75s02.html">75.2. fork() を 3
回コールする</a></span></dt>
<dt><span class="section"><a href="ch75s03.html">75.3. fork() を 4
回コールする</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch76.html">76. fstat
関数を使ってファイルサイズを指定する場合</a></span></dt>
<dt><span class="chapter"><a href="ch77.html">77. MAP_PRIVATE の
Copy-On-Write</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch77s01.html">77.1. fork() で
MAP_PRIVATE の Copy-On-Write を検証</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch78.html">78.
MAP_ANONYMOUS</a></span></dt>
<dt><span class="chapter"><a href="ch79.html">79.
アノニマスマッピング</a></span></dt>
<dt><span class="chapter"><a href="ch80.html">80. fork()
でプライベートファイルマッピングのチェック</a></span></dt>
<dt><span class="chapter"><a href="ch81.html">81. fork()
でプライベートアノニマスマッピングをチェック</a></span></dt>
<dt><span class="chapter"><a href="ch82.html">82. fork()
で共有ファイルマッピングをチェック</a></span></dt>
<dt><span class="chapter"><a href="ch83.html">83. fork()
で共有アノニマスマッピングをチェック</a></span></dt>
<dt><span class="chapter"><a href="ch84.html">84.
/dev/zero</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt07.html">VII.
（汎用ではない）カスタムアロケーターの設計</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch85.html">85.
アロケーターに必要な最低限の関数・オーバーロード・テンプレート</a></span></dt>
<dt><span class="chapter"><a href="ch86.html">86. std::allocator
を使うだけのリファレンスアロケーター</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch86s01.html">86.1.
std::allocator を模したカスタムアロケーター</a></span></dt>
</dl>
</dd>
</dl>
</dd>
<dt><span class="part"><a href="pt08.html">VIII.
スマートポインターで使えるデリーター</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch87.html">87.
スマートポインターの実装</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt09.html">IX.
スタック領域に割り当てるアロケーター</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch88.html">88.
配列内のアドレスの走査</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch88s01.html">88.1.
スタックアロケーター（可変長のリクエストサイズに対応、難易度高いのでスキップ推奨）</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch89.html">89.
ヒープへのフォールバック付きスタックアロケーター</a></span></dt>
<dt><span class="chapter"><a href="ch90.html">90.
コードをシンプルにする（内部バッファーのアドレスかのチェック）</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt10.html">X.
ヒープ領域のアドレスに割り当て</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch91.html">91.
ヒープ領域のアドレス</a></span></dt>
<dt><span class="chapter"><a href="ch92.html">92. malloc
を使ってヒープに割り当て</a></span></dt>
<dt><span class="chapter"><a href="ch93.html">93.
カスタムヒープアロケーター</a></span></dt>
<dt><span class="chapter"><a href="ch94.html">94. static
オブジェクトはヒープっぽい領域に割り当てられるはず？</a></span></dt>
<dt><span class="chapter"><a href="ch95.html">95.
アロケーターをスタティックメンバーにするとどうなるのか？</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt11.html">XI.
アロケーターをセレクターで切り替え</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch96.html">96.
アロケータークラス内での複数の割り当て方針を切り替え</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch96s01.html">96.1.
複数のアロケーターインスタンスを切り替え</a></span></dt>
</dl>
</dd>
</dl>
</dd>
<dt><span class="part"><a href="pt12.html">XII. C++ カスタムアロケーターの STL
サポート（実験）</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch97.html">97. C++
カスタムスタックアロケーターの用語の復習</a></span></dt>
<dt><span class="chapter"><a href="ch98.html">98. STL コンテナのサポート (
new / delete )</a></span></dt>
<dt><span class="chapter"><a href="ch99.html">99. STL
サポートの適用対象</a></span></dt>
<dt><span class="chapter"><a href="ch100.html">100. STL
コンテナ側のメモリー割り当て要件</a></span></dt>
<dt><span class="chapter"><a href="ch101.html">101. sizeof
を使った割り当てサイズの算出によるスタックアロケーター実装</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt13.html">XIII. mmap()
を使ったカスタムアロケーター</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch102.html">102.
ユーザーによるオブジェクト管理を前提にするカスタムページアロケーター</a></span></dt>
<dt><span class="chapter"><a href="ch103.html">103.
カスタムアロケーターによるブロック管理</a></span></dt>
</dl>
</dd>
<dt><span class="part"><a href="pt14.html">XIV.
（おまけ）アロケーターのポリモーフィズム</a></span></dt>
<dd>
<dl>
<dt><span class="chapter"><a href="ch104.html">104.
メモリーリソースクラス</a></span></dt>
<dt><span class="chapter"><a href="ch105.html">105.
std::experimental::pmr::memory_resource ( C++17 )</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch105s01.html">105.1.
memory_resource でアラインメントの実装（非実用的な実験です）</a></span></dt>
</dl>
</dd>
<dt><span class="chapter"><a href="ch106.html">106.
ポリモーフィックアロケーター</a></span></dt>
<dt><span class="chapter"><a href="ch107.html">107.
std::pmr::polymorphic_allocator ( C++17 )</a></span></dt>
<dt><span class="chapter"><a href="ch108.html">108.
std::experimental::pmr::vector コンテナ ( C++17 )</a></span></dt>
<dt><span class="chapter"><a href="ch109.html">109.
std::pmr::polymorphic_allocator の動作チェック</a></span></dt>
<dd>
<dl>
<dt><span class="section"><a href="ch109s01.html">109.1.
ポリモーフィックアロケーターの実装</a></span></dt>
</dl>
</dd>
</dl>
</dd>
</dl>
</div>
<div class="list-of-figures">
<p><strong>図の一覧</strong></p>
<dl>
<dt>30.1. <a href="ch30.html#idm1253">メインアリーナ（main_arena）</a></dt>
<dt>30.2. <a href="ch30.html#idm1266">スレッドアリーナ</a></dt>
<dt>32.1. <a href="ch32.html#idm1345">割り当て済みチャンク（allocated
chunk）</a></dt>
<dt>32.2. <a href="ch32.html#idm1372">割り当て済みチャンクの内部（allocated
chunk）</a></dt>
<dt>32.3. <a href="ch32.html#idm1382">フリーチャンク（free chunk）</a></dt>
<dt>32.4. <a href="ch32.html#idm1392">フリーチャンクの内部（small free
chunk、大きめでない場合）</a></dt>
<dt>39.1. <a href="ch39.html#idm2278">Unsorted/Small/Large
Bins</a></dt>
<dt>39.2. <a href="ch39.html#idm2306">Large Bins</a></dt>
<dt>68.1. <a href="ch68.html#idm3396">一段ページテーブル構成</a></dt>
<dt>68.2. <a href="ch68.html#idm3403">二段ページテーブル構成</a></dt>
<dt>68.3. <a href="ch68.html#idm3412">Linux 三段ページテーブル（Linux
2.6.11以前）</a></dt>
</dl>
</div>
<div class="list-of-tables">
<p><strong>表の一覧</strong></p>
<dl>
<dt>19.1. <a href="ch19.html#idm558">mode</a></dt>
<dt>35.1. <a href="ch35s01.html#idm1539">fastbin_index(sz)
の結果</a></dt>
<dt>37.1. <a href="ch37s01.html#idm1783">64 バイト間隔のインデックス</a></dt>
<dt>37.2. <a href="ch37s01.html#idm1838">512 バイト間隔のインデックス</a></dt>
<dt>37.3. <a href="ch37s01.html#idm1927">4096 バイト間隔のインデックス</a></dt>
<dt>37.4. <a href="ch37s01.html#idm1981">32768
バイト間隔のインデックス</a></dt>
<dt>37.5. <a href="ch37s01.html#idm2016">262144
バイト間隔のインデックス</a></dt>
<dt>73.1. <a href="ch73.html#idm3751">メモリー保護（ prot ）</a></dt>
</dl>
</div>
<p>Copyright 2018-2019, by Masaki Komatsu</p>
</body>
</html></body></html>