<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>第68章 ファイルとメモリーのマッピング (mmap)</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Linux で C/C++ の足固め： Linux の メモリー/ファイル/mmap と C++ アロケーター" /><link rel="up" href="pt05.html" title="パート V. Linux カーネルのメモリーとファイルシステム" /><link rel="prev" href="ch67.html" title="第67章 スラブレイヤー・スラブアロケーター" /><link rel="next" href="ch69.html" title="第69章 ページとハードウェア" /><script xmlns="" type="text/javascript" src="prettify/prettify.js"></script><link xmlns="" rel="stylesheet" type="text/css" href="prettify/skins/sons-of-obsidian.css" /><script xmlns="">
    window.addEventListener("load", function() {
      PR.prettyPrint();
	  });	
	</script><script xmlns="" type="text/javascript" src="script/head.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ch67.html">戻る</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch69.html">次へ</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="_ファイルとメモリーのマッピング_mmap"></a>第68章 ファイルとメモリーのマッピング (mmap)</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
mmap はファイルとメモリーアドレスのマッピングを行う
</li><li class="listitem">
mmap をしてもファイルデータが物理メモリーへ即ロードされない（レイジー最適化）
</li><li class="listitem">
データが物理メモリーにロードされてるかは MMU（メモリー管理ユニット）が検知してページフォルトを生成する
</li><li class="listitem">
OS カーネルがページフォルトをインターセプトしたら、やっとファイルデータはメモリーにロードされる
</li></ul></div><p>　mmap は Linux でファイルとメモリーのアドレスを紐付けて（マップして）、ファイルをメモリーかのようにアクセスできるようにしてくれる関数です。</p><p>　基本的な用途としてはメモリーの中身をハードディスクの中にあるファイルにバックアップを高い頻度でとりたい場合ですかね。</p><p>　もしくはディスク内のファイルを配列・バッファーのように読み込みたいとかです。</p><p>　まあ必ずしもファイルをマップする用途に限定されるわけじゃないですが、ここはお急がしい読者さんのために分かりやすい定義でいきましょう。</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">注記</h3><p>ここで説明している「ファイルマッピング」の他にも「無名マッピング（ Anonymous mapping ）」というものがあります。</p></div><p>　それでマップとは「なんなのら？」とお考えの読者は以下のイメージを見てくださいね。</p><div class="informalfigure"><div class="mediaobject"><img src="img/mmap_private.png" alt="img/mmap_private.png" /></div></div><p>　この図の「紐付けられた領域」は「マッピングされた領域」と考えればいいんです。</p><p>　つまりプロセスアドレス空間とファイルのデータが紐付けられているってことです。</p><p>　それでプロセスアドレス空間の内約については以下の図に示しますね。</p><div class="informalfigure"><div class="mediaobject"><img src="img/mmap_process.png" alt="img/mmap_process.png" /></div></div><p>　プロセスアドレス空間というのは別名で仮想アドレスとも言います。</p><p>　x86 アーキテクチャでは仮想アドレスはリニアアドレス（Linear Address）とも呼ばれてます。</p><p>　32 ビットの Linux であれば 4 GB が割り当てられ、うち 1 GB がカーネル部分となります。</p><div class="informalfigure"><div class="mediaobject"><img src="img/linux_address_space.png" alt="img/linux_address_space.png" /></div></div><p>　mmap でのマップの考え方としてはページテーブルが仮想アドレスから物理アドレスの翻訳（アドレストランスレーション）されるのを見ておくと良いでしょう。</p><div class="figure"><a id="idm3420"></a><p class="title"><strong>図68.1 一段ページテーブル構成</strong></p><div class="figure-contents"><div class="mediaobject"><img src="img/simple_pt_address_translation.png" alt="img/simple_pt_address_translation.png" /></div></div></div><br class="figure-break" /><div class="figure"><a id="idm3427"></a><p class="title"><strong>図68.2 二段ページテーブル構成</strong></p><div class="figure-contents"><div class="mediaobject"><img src="img/detail_pt_address_translation.png" alt="img/detail_pt_address_translation.png" /></div></div></div><br class="figure-break" /><p>　（開始 2 ビットを使う）一段テーブルも（開始 4 ビットを使う）二段テーブルもアドレストランスレーションの作法が異なるだけで最終的には物理アドレスに紐付けられてますよね。</p><p>　Linux ではページテーブルは以下のような三段構成になっています。</p><div class="figure"><a id="idm3436"></a><p class="title"><strong>図68.3 Linux 三段ページテーブル（Linux 2.6.11以前）</strong></p><div class="figure-contents"><div class="mediaobject"><img src="img/pgd_pmd_pte.png" alt="img/pgd_pmd_pte.png" /></div></div></div><br class="figure-break" /><p>　mm_struct は後で詳しく説明しますがメモリー記述子というオブジェクトでして、メモリーマッピングについての情報を保持します。</p><p>　PGD と PMD と PTE についてはアドレス階層の名前なのであまり深く考えなくても大丈夫です。</p><p>　最終的には解決したかった page オブジェクト、そしてそこから物理テーブルにたどり着きます。</p><p>　ちなみに Linux 2.6.11 以降では四段構成（ pgd, pud, pmd, pte ）となっています。</p><p>　mmap のプロセスアドレス空間でも、同様な考え方でページテーブルを使って物理アドレスを検索します。</p><p>　当然マップをしたらメモリー内のページにロードしたり、メモリー内のページに読み書きすることになりますね。</p><p>　ただ後の項目で説明しますが mmap ではページ内にデータがないので OS がデータをアクセスのたびにディスクからメモリーにロードしたりします。（使いすぎるとスワップメモリーに漏れるのでディスクとメモリーの区別はグダグダになりますけどね）</p><p>　それで OS の処理するイメージとしては以下のようにページフォールト（ Page Fault ）の例外をOSが処理してからディスクからメモリーへのロードが発生します。</p><div class="informalfigure"><div class="mediaobject"><img src="img/mmap_page_fault.png" alt="img/mmap_page_fault.png" /></div></div><p>　プロセスアドレス空間から物理アドレスへいくまえに MMU （メモリー管理ユニット）というCPU側の装置でデータが無いことをを検知し OS 側のページフォルトハンドラー（ Page Fault Handler ）がディスクから物理メモリーへのコピーをしてくれます。</p><p>　ちなみに2つ以上のプロセスから、ファイルにアクセスしたい場合は以下のようにします。</p><div class="informalfigure"><div class="mediaobject"><img src="img/mmap_shared.png" alt="img/mmap_shared.png" /></div></div><p>　このようにファイルをプロセスアドレス空間と紐付けてくれるわけです。</p><p>　ファイルマッピングについては、ちょっと大雑把なまとめだとは思うんですが、特にマジックじみた事はしていないので図示が可能だという認識ぐらい持ってもらえば大丈夫です。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch67.html">戻る</a> </td><td width="20%" align="center"><a accesskey="u" href="pt05.html">上に戻る</a></td><td width="40%" align="right"> <a accesskey="n" href="ch69.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div><p xmlns="">Copyright 2018-2019, by Masaki Komatsu</p></body></html>