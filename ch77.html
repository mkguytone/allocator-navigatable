<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>第77章 MAP_PRIVATE の Copy-On-Write</title><link rel="stylesheet" type="text/css" href="vol.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Linux で C/C++ の足固め： Linux の メモリー/ファイル/mmap と C++ アロケーター" /><link rel="up" href="pt06.html" title="パート VI. mmap" /><link rel="prev" href="ch76.html" title="第76章 fstat 関数を使ってファイルサイズを指定する場合" /><link rel="next" href="ch77s01.html" title="77.1. fork() で MAP_PRIVATE の Copy-On-Write を検証" /><script xmlns="" type="text/javascript" src="prettify/prettify.js"></script><link xmlns="" rel="stylesheet" type="text/css" href="prettify/skins/sons-of-obsidian.css" /><script xmlns="">
    window.addEventListener("load", function() {
      PR.prettyPrint();
	  });	
	</script><script xmlns="" type="text/javascript" src="script/head.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ch76.html">戻る</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch77s01.html">次へ</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="_map_private_の_copy_on_write"></a>第77章 MAP_PRIVATE の Copy-On-Write</h2></div></div></div><p>　mmap() を単なるファイルとのマップというのは概要としては良いんですが、技術者として見るとちょっと雑ですかね。</p><p>　mmap() は OS カーネルのアルゴリズムを使うので、具体的なデータフェッチの方式は各 OS の実装依存になります。</p><p>　でもスワップメモリーのようなスワップアルゴリズムのように絶えず IN/OUT を繰り返すような複雑なものは想定しなくても良いでしょう。</p><p>　あくまで mmap() はディスクとマッピングしてくれるといっても基本的にはメモリーにコピーしないと使えないから、まあ、メモリーと同じです。</p><p>　通常のメモリーと同じということは、解放もしてやらんといけないので munmap() というマッピングを解除・解放するための関数もあります。</p><p>　mmap() 関数で一気に数百 GB を使おうとすりゃ、そりゃ DRAM に入り切らずにスワップに漏れちゃうのは仕方ないですが、それであればメモリー内で作業していても同じ条件「デス」よね？</p><p>　mmap() 関数を呼び出してもディスクからデータをコピーしていないならマップされたメモリー領域は空のままです。</p><p>　これ重要なんで繰り返しますね。</p><p>　ディスクとメモリーをマップするだけでは、メモリーにデータはコピーされないので、未使用の段階では空の状態です。</p><p>　空のメモリー領域（ページ）にアクセスしようとすると、アドレスにデータが存在しないためページフォルト（ Page Fault ）が発生します。</p><p>　このページフォルトをカーネル内のハンドラ（ page fault handler ）が捕捉すると、データがコピーされます。</p><p>　くどいですが、もう一度前の項目の図を見てみましょうね。</p><div class="informalfigure"><div class="mediaobject"><img src="img/mmap_page_fault.png" alt="img/mmap_page_fault.png" /></div></div><p>　図のように mmap() は Linux のカーネルの機能を使ってディスクとのマッピングを行うのですが、重要な点はアプリケーションで使うタイミングです。</p><p>　アクセスしようとしたデータが存在しないならフォルトハンドラが例外を捉えて、そこから</p><p>　read() 関数を使うならメモリーに一旦コピーする事が必要ですが mmap() の場合は使用するたびにメモリーにコピーを行います。</p><p>　MAP_PRIVATE では mmap() をしただけでは基本的にメモリーは空のままです。</p><p>　しかしマップされたデータにアクセスしようとするとページフォルトが発生し、それをカーネルのハンドラが捉えてディスクからメモリーへのコピーをしてくれます。</p><p>　一度コピーされると、メモリーに入っているので使えるようにします。</p><p>　このコピーの実装については copy-on-write 方式が使われてるそうです。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
copy-on-write（ COW ）
</span></dt><dd>
プロセスの fork() をする際に完全なプロセスの複製を作るのではなく、リソースをどのタイミングでコピーするかを決める方式です。例えば fork() 関数によって新たな子プロセスを生成すと大昔にはページ毎に全ての内部構造とプロセスアドレス空間のコピーが行われましたが、このコピーコストは馬鹿にならないものでした。それに対し Copy-On-Write では、複数の fork() されたプロセスが同じ内容のリソースを読み込みアクセスする場合にはリソースの重複コピーはされず、リソースを指すポインターが与えられるようにしました。ですが同じリソースに対して変更・書き込みをしようとすると、ポインターの代わりにデータがコピーされます。データの変更や修正を加えようとする時だけデータがコピーされますが、他のプロセスはオリジナルの情報をそのまま参照することができます。
</dd></dl></div><p>　COW（copy-on-write）は典型的なレイジー最適化（lazy optimization）です。</p><p>　なぜならコピーが本当に必要になる瞬間にまでコピーを行わないため、プロセスの読み込み部分のコピーを省けるからです。</p><p>　てなことで Copy-on-write を理解できていれば mmap() 関数を使ったアロケーターの設計にも役だつでしょう。</p><p>　この項目もたぶん存在意義があるんですよ…</p><p>　(´・ω・｀)</p><p>　ただ mmap() 関数によるアロケーターは C++ に特化した人からすると BOOST があるので、あまり受けは良くないと思います。</p><p>　なのでこういうコンセプトがベースとなる Linux であるんだ程度の理解があればよろしいんじゃないですかね。</p><p>　(・∀・)</p><p>　ああ、それとスワップアルゴリズムは OS によるでしょうね。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch76.html">戻る</a> </td><td width="20%" align="center"><a accesskey="u" href="pt06.html">上に戻る</a></td><td width="40%" align="right"> <a accesskey="n" href="ch77s01.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div><p xmlns="">Copyright 2018-2019, by Masaki Komatsu</p></body></html>