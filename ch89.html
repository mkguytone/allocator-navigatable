<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>第89章 ヒープへのフォールバック付きスタックアロケーター</title><link rel="stylesheet" type="text/css" href="index.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Linux で C/C++ の足固め： Linux の メモリー/ファイル/mmap と C++ アロケーター" /><link rel="up" href="pt09.html" title="パート IX. スタック領域に割り当てるアロケーター" /><link rel="prev" href="ch88s01.html" title="88.1. スタックアロケーター（可変長のリクエストサイズに対応、難易度高いのでスキップ推奨）" /><link rel="next" href="ch90.html" title="第90章 コードをシンプルにする（内部バッファーのアドレスかのチェック）" /><script xmlns="" type="text/javascript" src="prettify/prettify.js"></script><link xmlns="" rel="stylesheet" type="text/css" href="prettify/skins/sons-of-obsidian.css" /><script xmlns="">
    window.addEventListener("load", function() {
      PR.prettyPrint();
	  });	
	</script><script xmlns="" type="text/javascript" src="script/head.js"></script><html:meta xmlns:html="http://www.w3.org/1999/xhtml" name="viewport" content="width=320, initial-scale=1"></html:meta></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ch88s01.html">戻る</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch90.html">次へ</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="_ヒープへのフォールバック付きスタックアロケーター"></a>第89章 ヒープへのフォールバック付きスタックアロケーター</h2></div></div></div><p>　前の項目はデータ構造が少し難しめだったので、この項目では STL コンテナをフル活用してコードを読みやすくすることと、バッファーオーバーフロー時にエラーを投げるのではなく、ヒープへのフォールバックを実装してみたいと思います。</p><p>　ヒープフォールバック付きのスタックアロケーターの実装はヒープをすこしばかり改造するというアプローチで良いかと思います。</p><p>　まず最大の違いはヒープのように delete は不要なところです。</p><p>　それとスタックにはすでにメモリー領域が固定長ではありますが確保されてるので new も不要です。</p><p>　しかし使用できるアドレスの範囲内にオブジェクトを作るためにプレースメント new を使うことになります。</p><p>　ではコードを見てみましょう。</p><p><strong>main.cpp. </strong>
</p><pre xmlns="" class="prettyprint">  1 #include &lt;memory&gt;
  2 #include &lt;vector&gt;
  3 #include &lt;iostream&gt;
  4 #include &lt;cassert&gt;
  5 #include &lt;cstddef&gt;
  6 #include &lt;map&gt;
  7
  8 template&lt;typename T, std::size_t N, typename Allocator = std::allocator&lt;T&gt;&gt;
  9 class stack_allocator
 10 {
 11 public:
 12   typedef typename std::allocator_traits&lt;Allocator&gt;::value_type value_type;
 13   typedef typename std::allocator_traits&lt;Allocator&gt;::pointer pointer;
 14   typedef typename std::allocator_traits&lt;Allocator&gt;::const_pointer const_pointer;
 15   typedef typename std::allocator_traits&lt;Allocator&gt;::size_type size_type;
 16   typedef typename std::allocator_traits&lt;Allocator&gt;::difference_type difference_type;
 17   typedef typename std::allocator_traits&lt;Allocator&gt;::void_pointer void_pointer;
 18   typedef typename std::allocator_traits&lt;Allocator&gt;::const_void_pointer const_void_pointer;
 19   typedef typename Allocator::reference reference;
 20   typedef typename Allocator::const_reference const_reference;
 21
 22   typedef std::map&lt;void*,size_t&gt; size_map_t;
 23   typedef std::map&lt;size_t,std::vector&lt;void*&gt;&gt; free_list_t;
 24   typedef std::byte byte;
 25
 26   typedef Allocator allocator_type;
 27
 28   explicit stack_allocator(const allocator_type&amp; alloc = allocator_type())
 29     : M_allocator_(alloc),
 30     M_block_size_(sizeof(T) &lt; 8 ? sizeof(long long) : sizeof(T)),
 31     M_max_objects_(N),
 32     M_begin_(M_buffer_),
 33     M_end_(M_buffer_+M_block_size_*M_max_objects_),
 34     M_stack_pointer_(M_buffer_)
 35   {}
 36
 37   template&lt;typename U&gt;
 38   stack_allocator(const stack_allocator&lt;U,N,Allocator&gt;&amp; other)
 39     : M_allocator_(other.M_allocator_),
 40     M_block_size_(sizeof(T) &lt; 8 ? sizeof(long long) : sizeof(T)),
 41     M_max_objects_(N),
 42     M_begin_(other.M_begin_),
 43     M_end_(other.M_end_),
 44     M_stack_pointer_(other.M_stack_pointer_)
 45   {}
 46
 47   template&lt;typename U&gt;
 48   struct rebind
 49   {
 50     typedef stack_allocator&lt;U,N,allocator_type&gt; other;
 51   };
 52
 53   pointer allocate(size_type n, const_void_pointer hint = const_void_pointer())
 54   {
 55     auto&amp; free_chunks = M_free_list_[n*M_block_size_];
 56     if(!free_chunks.empty()){
 57       pointer available_block = static_cast&lt;T*&gt;(free_chunks.back());
 58       free_chunks.pop_back();
 59       std::cout &lt;&lt; "reuse pointer: " &lt;&lt; available_block &lt;&lt; '\n';
 60       return available_block;
 61     } else if(M_stack_pointer_ + n * M_block_size_ &gt; M_end_){
 62       std::printf("over the stack capacity, fall back to default allocator\n");
 63       M_stack_pointer_ += n * M_block_size_;
 64       return M_allocator_.allocate(n);
 65     }
 66
 67     pointer new_block = reinterpret_cast&lt;pointer&gt;(M_stack_pointer_);
 68     M_stack_pointer_ += n*M_block_size_;
 69     M_size_map_[new_block] = n*M_block_size_;
 70     std::cout &lt;&lt; "new pointer: " &lt;&lt; new_block &lt;&lt; " M_stack_pointer_: " &lt;&lt; M_stack_pointer_ &lt;&lt; '\n';
 71     return new_block;
 72   }
 73
 74   void deallocate(pointer p, size_type n)
 75   {
 76     auto freed_chunk_size = M_size_map_[(void*)p];
 77     if(freed_chunk_size != 0){ // value should be initialized to zero if the map is empty
 78       M_free_list_[freed_chunk_size].push_back((void*)p);
 79     } else if(M_stack_pointer_ &gt; M_end_){
 80       M_allocator_.deallocate(p,n);
 81       freed_chunk_size = n * M_block_size_;
 82     }
 83     std::printf("deallocate: %p with size %lu\n",p,freed_chunk_size);
 84   }
 85
 86   size_type max_size() const noexcept
 87   {
 88     return (size_type)(~0) / sizeof(T);
 89   }
 90
 91   template&lt;typename U, typename... Args&gt;
 92   void construct(U* p, Args&amp;&amp;... args)
 93   {
 94     ::new ((void*)p) T(args...);
 95   }
 96
 97   template&lt;typename U&gt;
 98   void destroy(U* p)
 99   {
100     p-&gt;~T();
101   }
102
103   pointer address(reference x) const noexcept
104   {
105     return std::addressof(x);
106   }
107
108   const_pointer address(const_reference x) const noexcept
109   {
110     return addressof(x);
111   }
112
113   pointer buffer() const noexcept
114   {
115     return M_begin_;
116   }
117
118   constexpr static size_type capacity()
119   {
120     return N;
121   }
122
123 private:
124
125   allocator_type M_allocator_;
126   size_map_t M_size_map_;
127   free_list_t M_free_list_;
128
129   byte M_buffer_[N];
130   const size_type M_block_size_;
131   const size_type M_max_objects_;
132   byte* M_begin_;
133   byte* M_end_;
134   byte* M_stack_pointer_;
135 };
136
137 template&lt;typename T1, std::size_t N, typename Allocator, typename T2&gt;
138 bool operator==(const stack_allocator&lt;T1,N,Allocator&gt;&amp; lhs, const stack_allocator&lt;T2,N,Allocator&gt;&amp; rhs) noexcept
139 {
140   return lhs.buffer() == rhs.buffer();
141 }
142
143 template&lt;typename T1, std::size_t N, typename Allocator, typename T2&gt;
144 bool operator!=(const stack_allocator&lt;T1,N,Allocator&gt;&amp; lhs, const stack_allocator&lt;T2,N,Allocator&gt;&amp; rhs) noexcept
145 {
146   return !(lhs == rhs);
147 }
148
149 const std::size_t stack_size = 8;
150
151 int main()
152 {
153   typedef stack_allocator&lt;int,stack_size&gt; alloc_t;
154
155   alloc_t alloc;
156   int* t = alloc.allocate(1);
157   alloc.construct(t,100);
158   std::cout &lt;&lt; *t &lt;&lt; '\n';
159   alloc.destroy(t);
160   alloc.deallocate(t,1);
161
162   int* d[16];
163   for(int i = 0; i &lt; 5; ++i){
164     d[i] = alloc.allocate(1);
165   }
166   for(int i = 1; i &lt; 5; ++i){
167     alloc.deallocate(d[i],1);
168   }
169   for(int i = 5; i &lt; 16; ++i){
170     d[i] = alloc.allocate(1);
171   }
172   for(int i = 5; i &lt; 16; ++i){
173     alloc.deallocate(d[i],1);
174   }
175 }</pre><p>
</p><p>　このソースコードをビルドして実行すると以下のような出力となります。</p><pre xmlns="" class="prettyprint">$ g++ main.cpp -std=c++17 -g
$ ./a.out
new pointer: 0x7ffe83fa1e08 M_stack_pointer_: 0x7ffe83fa1e10
100
deallocate: 0x7ffe83fa1e08 with size 8
reuse pointer: 0x7ffe83fa1e08
new pointer: 0x7ffe83fa1e10 M_stack_pointer_: 0x7ffe83fa1e18
new pointer: 0x7ffe83fa1e18 M_stack_pointer_: 0x7ffe83fa1e20
new pointer: 0x7ffe83fa1e20 M_stack_pointer_: 0x7ffe83fa1e28
new pointer: 0x7ffe83fa1e28 M_stack_pointer_: 0x7ffe83fa1e30
deallocate: 0x7ffe83fa1e10 with size 8
deallocate: 0x7ffe83fa1e18 with size 8
deallocate: 0x7ffe83fa1e20 with size 8
deallocate: 0x7ffe83fa1e28 with size 8
reuse pointer: 0x7ffe83fa1e28
reuse pointer: 0x7ffe83fa1e20
reuse pointer: 0x7ffe83fa1e18
reuse pointer: 0x7ffe83fa1e10
new pointer: 0x7ffe83fa1e30 M_stack_pointer_: 0x7ffe83fa1e38
new pointer: 0x7ffe83fa1e38 M_stack_pointer_: 0x7ffe83fa1e40
new pointer: 0x7ffe83fa1e40 M_stack_pointer_: 0x7ffe83fa1e48
over the stack capacity, fall back to default allocator
over the stack capacity, fall back to default allocator
over the stack capacity, fall back to default allocator
over the stack capacity, fall back to default allocator
deallocate: 0x7ffe83fa1e28 with size 8
deallocate: 0x7ffe83fa1e20 with size 8
deallocate: 0x7ffe83fa1e18 with size 8
deallocate: 0x7ffe83fa1e10 with size 8
deallocate: 0x7ffe83fa1e30 with size 8
deallocate: 0x7ffe83fa1e38 with size 8
deallocate: 0x7ffe83fa1e40 with size 8
deallocate: 0x55f7af9cf430 with size 8
deallocate: 0x55f7af9cf310 with size 8
deallocate: 0x55f7af9cf540 with size 8
deallocate: 0x55f7af9cf560 with size 8</pre><p>　このコードでは allocate() / deallocate() を使うケースと std::vector を使うケースの 2 パターンをテストしています。</p><p>　まずはコンストラクターです。</p><pre xmlns="" class="prettyprint">  8 template&lt;typename T, std::size_t N, typename Allocator = std::allocator&lt;T&gt;&gt;
  9 class stack_allocator
 10 {
 11 public:

 // 中略

 22   typedef std::map&lt;void*,size_t&gt; size_map_t;
 23   typedef std::map&lt;size_t,std::vector&lt;void*&gt;&gt; free_list_t;
 24   typedef std::byte byte;

 // 中略

 28   explicit stack_allocator(const allocator_type&amp; alloc = allocator_type())
 29     : M_allocator_(alloc),
 30     M_block_size_(sizeof(T) &lt; 8 ? sizeof(long long) : sizeof(T)),
 31     M_max_objects_(N),
 32     M_begin_(M_buffer_),
 33     M_end_(M_buffer_+M_block_size_*M_max_objects_),
 34     M_stack_pointer_(M_buffer_)
 35   {}
 36
 37   template&lt;typename U&gt;
 38   stack_allocator(const stack_allocator&lt;U,N,Allocator&gt;&amp; other)
 39     : M_allocator_(other.M_allocator_),
 40     M_block_size_(sizeof(T) &lt; 8 ? sizeof(long long) : sizeof(T)),
 41     M_max_objects_(N),
 42     M_begin_(other.M_begin_),
 43     M_end_(other.M_end_),
 44     M_stack_pointer_(other.M_stack_pointer_)
 45   {}

// 中略

123 private:
124
125   allocator_type M_allocator_;
126   size_map_t M_size_map_;
127   free_list_t M_free_list_;
128
129   byte M_buffer_[N];
130   const size_type M_block_size_;
131   const size_type M_max_objects_;
132   byte* M_begin_;
133   byte* M_end_;
134   byte* M_stack_pointer_;
135 };</pre><p>　コピーコンストラクターが std::allocator のインスタンスを M_allocator_ にデフォルトでコピーしてます。</p><p>　M_allocator_ はこのソースコードでフォールバックとして使用しているので無視してもらっても結構ですが、デフォルトアロケーターとして持っておくと便利です。</p><p>　フォールバック用のデフォルトアロケーターがあると便利なのは、スタックアロケーターでは一定限度以上の割り当てが必要な場合はヒープ領域に割り当てる実装が一般的だからです。</p><p>　テンプレートパラメーター N はバッファーのバイトサイズを定義するために使われます。</p><p>　つまり M_buffer_[] 配列は N バイトの記憶域となります。</p><p>　M_block_size_ はこのアロケーターが割り当てる固定サイズです。</p><p>　M_begin_ と M_end_ は開始と終端のアドレスです。</p><p>　M_stack_pointer_ はスタックポインター、つまり現在使用中の最新の位置ってことで、これを割り当て時に加算し、開放時に減算します。</p><p>　アロケーターのメモリー管理機能は 2 つの型によって行います。</p><pre xmlns="" class="prettyprint"> 22   typedef std::map&lt;void*,size_t&gt; size_map_t;
 23   typedef std::map&lt;size_t,std::vector&lt;void*&gt;&gt; free_list_t;</pre><p>　オブジェクト定義のほうは以下の 2 行です。</p><pre xmlns="" class="prettyprint">126   size_map_t M_size_map_;
127   free_list_t M_free_list_;</pre><p>　M_size_map_ はポインターから、割り当てられたバイトサイズを探すためのマップデータ構造です。</p><p>　M_free_list_ は割り当てバイトサイズから、フリーリストの std::vector データ構造を探すためのマップです。</p><p>　この 2 つはメモリー再利用の機能を実装するには不可欠となるのですが、考え方としてはメモリーの</p><p>　まあ複雑なので実装をみたほうが早いかもしれないです。</p><p>　次に allocate() 関数を見てみましょう。</p><pre xmlns="" class="prettyprint"> 53   pointer allocate(size_type n, const_void_pointer hint = const_void_pointer())
 54   {
 55     auto&amp; free_chunks = M_free_list_[n*M_block_size_];
 56     if(!free_chunks.empty()){
 57       pointer available_block = static_cast&lt;T*&gt;(free_chunks.back());
 58       free_chunks.pop_back();
 59       std::cout &lt;&lt; "reuse pointer: " &lt;&lt; available_block &lt;&lt; '\n';
 60       return available_block;
 61     } else if(M_stack_pointer_ + n * M_block_size_ &gt; M_end_){
 62       std::printf("over the stack capacity, fall back to default allocator\n");
 63       M_stack_pointer_ += n * M_block_size_;
 64       return M_allocator_.allocate(n);
 65     }
 66
 67     pointer new_block = reinterpret_cast&lt;pointer&gt;(M_stack_pointer_);
 68     M_stack_pointer_ += n*M_block_size_;
 69     M_size_map_[new_block] = n*M_block_size_;
 70     std::cout &lt;&lt; "new pointer: " &lt;&lt; new_block &lt;&lt; " M_stack_pointer_: " &lt;&lt; M_stack_pointer_ &lt;&lt; '\n';
 71     return new_block;
 72   }</pre><p>　スタックポインターのアドレスを new_block に代入し返しますが、その直前に M_stack_pointer_ のアドレスを n * M_block_size_ 分だけ加算して、次の割り当てに使うアドレスを取得しておきます。</p><pre xmlns="" class="prettyprint"> 67     pointer new_block = reinterpret_cast&lt;pointer&gt;(M_stack_pointer_);
 68     M_stack_pointer_ += n*M_block_size_;
 69     M_size_map_[new_block] = n*M_block_size_;</pre><p>　それと終端アドレス超えた場合のセーフガードとしてデフォルトアロケーター( std::allocator )がコールされるようしています。</p><pre xmlns="" class="prettyprint"> 61     } else if(M_stack_pointer_ + n * M_block_size_ &gt; M_end_){
 62       std::printf("over the stack capacity, fall back to default allocator\n");
 63       M_stack_pointer_ += n * M_block_size_;
 64       return M_allocator_.allocate(n);
 65     }</pre><p>　後は解放されてフリーな状態のチャンク・ブロックを再利用するロジックです。</p><pre xmlns="" class="prettyprint"> 55     auto&amp; free_chunks = M_free_list_[n*M_block_size_];
 56     if(!free_chunks.empty()){
 57       pointer available_block = static_cast&lt;T*&gt;(free_chunks.back());
 58       free_chunks.pop_back();
 59       std::cout &lt;&lt; "reuse pointer: " &lt;&lt; available_block &lt;&lt; '\n';
 60       return available_block;</pre><p>　ここでは、リクエストサイズのフリーチャンクが M_free_list_ に存在するかチェックしています。</p><pre xmlns="" class="prettyprint"> 55     auto&amp; free_chunks = M_free_list_[n*M_block_size_];
 56     if(!free_chunks.empty()){</pre><p>　もし empty() が真を返すならば再利用できるフリーチャンクは存在せず、偽を返すならば再利用できるフリーチャンク・フリーブロックが存在するということです。</p><p>　もしフリーチャンクがあるなら、後はそれを返すだけですが、取り出しあとにポップしておきます。</p><pre xmlns="" class="prettyprint"> 57       pointer available_block = static_cast&lt;T*&gt;(free_chunks.back());
 58       free_chunks.pop_back();</pre><p>　次に deallocate() を見てみましょう。</p><pre xmlns="" class="prettyprint"> 74   void deallocate(pointer p, size_type n)
 75   {
 76     auto freed_chunk_size = M_size_map_[(void*)p];
 77     if(freed_chunk_size != 0){ // value should be initialized to zero if the map is empty
 78       M_free_list_[freed_chunk_size].push_back((void*)p);
 79     } else if(M_stack_pointer_ &gt; M_end_){
 80       M_allocator_.deallocate(p,n);
 81       freed_chunk_size = n * M_block_size_;
 82     }
 83     std::printf("deallocate: %p with size %lu\n",p,freed_chunk_size);
 84   }</pre><p>　アロケーターではスタックポインターにブロックサイズを加算した状態なので、アロケーターのオーバーフローのチェックは以下の行で行います。</p><pre xmlns="" class="prettyprint"> 79     } else if(M_stack_pointer_ &gt; M_end_){
 80       M_allocator_.deallocate(p,n);
 81       freed_chunk_size = n * M_block_size_;
 82     }</pre><p>　このようにデフォルトアロケーター M_allocator_ の deallocate() 関数をコールするだけです。</p><p>　次にスタック領域内のチャンクについてです。</p><p>　スタック領域のチャンクは M_size_map_ に登録されています。もとは allocate() 関数で追加されています。</p><p>　M_size_map_ から p ポインターを照合する場合、返ってきた値が 0 ならデータが存在しないということになります。</p><pre xmlns="" class="prettyprint"> 76     auto freed_chunk_size = M_size_map_[(void*)p];
 77     if(freed_chunk_size != 0){ // value should be initialized to zero if the map is empty
 78       M_free_list_[freed_chunk_size].push_back((void*)p);</pre><p>　該当するポインターが存在する場合はフリーチャンクとしてフリーリストに登録を行います。</p><p>　それとテストのほうもみておきましょうかね。</p><p>　まずスタックのサイズは 8 としておきますが、これは 8 バイトではなく、ブロックサイズのことです。</p><pre xmlns="" class="prettyprint">149 const std::size_t stack_size = 8;
150
151 int main()
152 {
153   typedef stack_allocator&lt;int,stack_size&gt; alloc_t;
154
155   alloc_t alloc;
156   int* t = alloc.allocate(1);
157   alloc.construct(t,100);
158   std::cout &lt;&lt; *t &lt;&lt; '\n';
159   alloc.destroy(t);
160   alloc.deallocate(t,1);
161
162   int* d[16];
163   for(int i = 0; i &lt; 5; ++i){
164     d[i] = alloc.allocate(1);
165   }
166   for(int i = 1; i &lt; 5; ++i){
167     alloc.deallocate(d[i],1);
168   }
169   for(int i = 5; i &lt; 16; ++i){
170     d[i] = alloc.allocate(1);
171   }
172   for(int i = 5; i &lt; 16; ++i){
173     alloc.deallocate(d[i],1);
174   }</pre><p>　最初は int 型を指す領域を 1 個だけ割り当て、すぎに解放しておきます。</p><pre xmlns="" class="prettyprint">155   alloc_t alloc;
156   int* t = alloc.allocate(1);
157   alloc.construct(t,100);
158   std::cout &lt;&lt; *t &lt;&lt; '\n';
159   alloc.destroy(t);
160   alloc.deallocate(t,1);</pre><p>　一応 construct() でオブジェクトを初期化し destroy() で破壊もしておいています。</p><p>　次に解放したポインター再利用のロジックの実装が動作するかチェックしますね。</p><p>　やってる事は i が 0,1,2,3,4 （合計 5 個）の時に allocate() 関数を呼びます。</p><pre xmlns="" class="prettyprint">reuse pointer: 0x7ffe83fa1e08
new pointer: 0x7ffe83fa1e10 M_stack_pointer_: 0x7ffe83fa1e18
new pointer: 0x7ffe83fa1e18 M_stack_pointer_: 0x7ffe83fa1e20
new pointer: 0x7ffe83fa1e20 M_stack_pointer_: 0x7ffe83fa1e28
new pointer: 0x7ffe83fa1e28 M_stack_pointer_: 0x7ffe83fa1e30</pre><p>　さらに i が 1,2,3,4 （合計 4 個）の時に deallocate() 関数をコールします。</p><pre xmlns="" class="prettyprint">deallocate: 0x7ffe83fa1e10 with size 8
deallocate: 0x7ffe83fa1e18 with size 8
deallocate: 0x7ffe83fa1e20 with size 8
deallocate: 0x7ffe83fa1e28 with size 8</pre><p>　そして i が 5,6,7,8,9,10,11,12,13,14,15 （合計 11 個）の時に allocate() 関数と呼びます。</p><pre xmlns="" class="prettyprint">reuse pointer: 0x7ffe83fa1e28
reuse pointer: 0x7ffe83fa1e20
reuse pointer: 0x7ffe83fa1e18
reuse pointer: 0x7ffe83fa1e10
new pointer: 0x7ffe83fa1e30 M_stack_pointer_: 0x7ffe83fa1e38
new pointer: 0x7ffe83fa1e38 M_stack_pointer_: 0x7ffe83fa1e40
new pointer: 0x7ffe83fa1e40 M_stack_pointer_: 0x7ffe83fa1e48
over the stack capacity, fall back to default allocator
over the stack capacity, fall back to default allocator
over the stack capacity, fall back to default allocator
over the stack capacity, fall back to default allocator</pre><p>　この際に前もって deallocate() でフリーチャンクが 4 個分 M_free_list_ に登録されているので、その分を再利用します。</p><p>　すると 7 個分までがスタック領域に割り当てられ、残りの 4 個分がヒープ領域に割り当てられます。</p><p>　最後に最初に作った分と合わせ合計 12 個分のポインターに対して deallocate() 関数をコールします。</p><pre xmlns="" class="prettyprint">deallocate: 0x7ffe83fa1e28 with size 8
deallocate: 0x7ffe83fa1e20 with size 8
deallocate: 0x7ffe83fa1e18 with size 8
deallocate: 0x7ffe83fa1e10 with size 8
deallocate: 0x7ffe83fa1e30 with size 8
deallocate: 0x7ffe83fa1e38 with size 8
deallocate: 0x7ffe83fa1e40 with size 8
deallocate: 0x55f7af9cf430 with size 8
deallocate: 0x55f7af9cf310 with size 8
deallocate: 0x55f7af9cf540 with size 8
deallocate: 0x55f7af9cf560 with size 8</pre><p>　スタック領域のポインターらしきものが 8 個、ヒープ領域のポインターらしきものが 4 個解放されています。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch88s01.html">戻る</a> </td><td width="20%" align="center"><a accesskey="u" href="pt09.html">上に戻る</a></td><td width="40%" align="right"> <a accesskey="n" href="ch90.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div><wrapper xmlns=""><p>Copyright 2018-2019, by Masaki Komatsu</p>

<div class="toc"><p><strong>目次</strong></p><dl class="toc"><dt><span class="preface"><a href="pr01.html">序文</a></span></dt><dd><dl><dt><span class="section"><a href="pr01s01.html">1. Linux カーネルを学ぶ意義</a></span></dt><dt><span class="section"><a href="pr01s02.html">2. C++ カスタムアロケーターを作る意義</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch01.html">1. 対象となる読者</a></span></dt><dt><span class="chapter"><a href="ch02.html">2. 前提知識</a></span></dt><dt><span class="chapter"><a href="ch03.html">3. 開発環境</a></span></dt><dd><dl><dt><span class="section"><a href="ch03s01.html">3.1. Linux カーネルのバージョンを揃える</a></span></dt></dl></dd><dt><span class="part"><a href="pt01.html">I. Linux と POSIX C</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch04.html">4. パイプとリダイレクトのまとめ</a></span></dt><dt><span class="chapter"><a href="ch05.html">5. echo コマンド</a></span></dt><dt><span class="chapter"><a href="ch06.html">6. シェルの確認</a></span></dt><dt><span class="chapter"><a href="ch07.html">7. /dev ディレクトリー</a></span></dt><dd><dl><dt><span class="section"><a href="ch07s01.html">7.1. echo のリダイレクト</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch08.html">8. アペンド</a></span></dt><dt><span class="chapter"><a href="ch09.html">9. リダイレクトのファイル記述子</a></span></dt><dt><span class="chapter"><a href="ch10.html">10. ファイル記述子間のリダイレクト</a></span></dt><dt><span class="chapter"><a href="ch11.html">11. ファイル記述子リダイレクトのまとめ</a></span></dt><dt><span class="chapter"><a href="ch12.html">12. exec (bash)</a></span></dt><dt><span class="chapter"><a href="ch13.html">13. ファイル記述子を閉じる</a></span></dt><dt><span class="chapter"><a href="ch14.html">14. 読み書きファイル記述子</a></span></dt><dt><span class="chapter"><a href="ch15.html">15. /proc ディレクトリー</a></span></dt><dt><span class="chapter"><a href="ch16.html">16. /dev/shm ディレクトリー</a></span></dt></dl></dd><dt><span class="part"><a href="pt02.html">II. Linux (POSIX) のファイル入出力</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch17.html">17. system 関数</a></span></dt><dt><span class="chapter"><a href="ch18.html">18. fprintf 関数</a></span></dt><dt><span class="chapter"><a href="ch19.html">19. open / dprintf 関数</a></span></dt><dt><span class="chapter"><a href="ch20.html">20. read() / write() 関数</a></span></dt><dd><dl><dt><span class="section"><a href="ch20s01.html">20.1. 文字列をヒープにコピー</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch21.html">21. lseek()</a></span></dt><dt><span class="chapter"><a href="ch22.html">22. fopen / fread / fwrite / fclose 関数</a></span></dt></dl></dd><dt><span class="part"><a href="pt03.html">III. Linux でメモリー割り当て</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch23.html">23. 32 ビットプロセスのレイアウト</a></span></dt><dt><span class="chapter"><a href="ch24.html">24. malloc (cstdlib)</a></span></dt><dt><span class="chapter"><a href="ch25.html">25. malloc を strace で検証してみる</a></span></dt><dd><dl><dt><span class="section"><a href="ch25s01.html">25.1. ASLR と共有オブジェクト</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch26.html">26. MALLOC(3) Linux プログラマーマニュアル</a></span></dt><dt><span class="chapter"><a href="ch27.html">27. brk / sbrk (unistd.h)</a></span></dt><dd><dl><dt><span class="section"><a href="ch27s01.html">27.1. gdb で sbrk() の解析</a></span></dt><dt><span class="section"><a href="ch27s02.html">27.2. strace によって brk() / malloc() のコールをチェック</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="pt04.html">IV. glibc から malloc() の基本構造を理解してみる</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch28.html">28. malloc() の内部実装</a></span></dt><dt><span class="chapter"><a href="ch29.html">29. アリーナによるマルチスレッド対応</a></span></dt><dt><span class="chapter"><a href="ch30.html">30. アリーナオブジェクト（ main_arena / malloc_state ）</a></span></dt><dt><span class="chapter"><a href="ch31.html">31. ヒープのヘッダーオブジェクト（ heap_info )</a></span></dt><dt><span class="chapter"><a href="ch32.html">32. チャンク（ malloc_chunk ）</a></span></dt><dt><span class="chapter"><a href="ch33.html">33. 最少チャンクサイズと最少割り当てサイズ</a></span></dt><dt><span class="chapter"><a href="ch34.html">34. malloc_par</a></span></dt><dt><span class="chapter"><a href="ch35.html">35. top チャンク</a></span></dt><dd><dl><dt><span class="section"><a href="ch35s01.html">35.1. ビン</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch36.html">36. 未整理ビン / スモールビン / ラージビン</a></span></dt><dt><span class="chapter"><a href="ch37.html">37. ビンのインデックスの計算</a></span></dt><dd><dl><dt><span class="section"><a href="ch37s01.html">37.1. 32 ビットアーキテクチャのビン</a></span></dt><dt><span class="section"><a href="ch37s02.html">37.2. 64 ビットアーキテクチャのビン</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch38.html">38. ビン・インデックスのまとめ</a></span></dt><dt><span class="chapter"><a href="ch39.html">39. ビンのチャンク連結</a></span></dt><dt><span class="chapter"><a href="ch40.html">40. ビンの初期化</a></span></dt><dt><span class="chapter"><a href="ch41.html">41. 未整理チャンク（ Unsorted Chunk ）のマクロ</a></span></dt><dt><span class="chapter"><a href="ch42.html">42. トップチャンク（ Top Chunk ）のマクロ</a></span></dt><dt><span class="chapter"><a href="ch43.html">43. Binmap のマクロ</a></span></dt><dt><span class="chapter"><a href="ch44.html">44. tcache</a></span></dt><dt><span class="chapter"><a href="ch45.html">45. malloc() フリーチャンクの挙動</a></span></dt><dt><span class="chapter"><a href="ch46.html">46. malloc.c の内部マクロ</a></span></dt><dd><dl><dt><span class="section"><a href="ch46s01.html">46.1. チャンクを取り扱えるマクロ</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch47.html">47. ファーストビンの解放</a></span></dt><dt><span class="chapter"><a href="ch48.html">48. malloc.c の内部関数</a></span></dt><dt><span class="chapter"><a href="ch49.html">49. malloc() の実装</a></span></dt><dd><dl><dt><span class="section"><a href="ch49s01.html">49.1. _int_malloc() 関数</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch50.html">50. free() の実装</a></span></dt><dt><span class="chapter"><a href="ch51.html">51. calloc()</a></span></dt><dt><span class="chapter"><a href="ch52.html">52. realloc()</a></span></dt><dt><span class="chapter"><a href="ch53.html">53. alloca() 関数</a></span></dt><dd><dl><dt><span class="section"><a href="ch53s01.html">53.1. alloca() の使用法</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch54.html">54. posix_memalign() / aligned_alloc()</a></span></dt><dd><dl><dt><span class="section"><a href="ch54s01.html">54.1. glibc-2.7 の内部実装</a></span></dt><dt><span class="section"><a href="ch54s02.html">54.2. アラインメントの仕組み</a></span></dt><dt><span class="section"><a href="ch54s03.html">54.3. アラインメントの最少サイズ</a></span></dt><dt><span class="section"><a href="ch54s04.html">54.4. 大きめのアラインメント</a></span></dt><dt><span class="section"><a href="ch54s05.html">54.5. 複数のアラインメントでの検証</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch55.html">55. std::launder ( C++17 )</a></span></dt><dt><span class="chapter"><a href="ch56.html">56. std::aligned_storage ( C++11 )</a></span></dt><dt><span class="chapter"><a href="ch57.html">57. std::align ( C++11 )</a></span></dt><dt><span class="chapter"><a href="ch58.html">58. std::aligned_alloc ( C++17 )</a></span></dt></dl></dd><dt><span class="part"><a href="pt05.html">V. Linux カーネルのメモリーとファイルシステム</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch59.html">59. Linux の仮想メモリーエリア・メモリー記述子</a></span></dt><dt><span class="chapter"><a href="ch60.html">60. メモリー記述子（ mm_struct ）</a></span></dt><dt><span class="chapter"><a href="ch61.html">61. 仮想メモリー領域（ vm_area_struct ）</a></span></dt><dt><span class="chapter"><a href="ch62.html">62. ページ記述子（ struct page ）</a></span></dt><dt><span class="chapter"><a href="ch63.html">63. ページとブロック</a></span></dt><dt><span class="chapter"><a href="ch64.html">64. バッファー ( buffer_head )</a></span></dt><dt><span class="chapter"><a href="ch65.html">65. ブロック I/O ( bio )</a></span></dt><dt><span class="chapter"><a href="ch66.html">66. ページのキャッシュ</a></span></dt><dt><span class="chapter"><a href="ch67.html">67. スラブレイヤー・スラブアロケーター</a></span></dt><dt><span class="chapter"><a href="ch68.html">68. ファイルとメモリーのマッピング (mmap)</a></span></dt><dt><span class="chapter"><a href="ch69.html">69. ページとハードウェア</a></span></dt><dt><span class="chapter"><a href="ch70.html">70. ページキャッシュ ( struct address_space )</a></span></dt><dt><span class="chapter"><a href="ch71.html">71. Linux のファイルシステム</a></span></dt><dd><dl><dt><span class="section"><a href="ch71s01.html">71.1. カーネルヘッダー ( /usr/src/ )</a></span></dt><dt><span class="section"><a href="ch71s02.html">71.2. カーネルソースのアーカイブ</a></span></dt><dt><span class="section"><a href="ch71s03.html">71.3. super_block (カーネル)</a></span></dt><dt><span class="section"><a href="ch71s04.html">71.4. inode (カーネル)</a></span></dt><dt><span class="section"><a href="ch71s05.html">71.5. dentry (カーネル)</a></span></dt><dt><span class="section"><a href="ch71s06.html">71.6. file (カーネル)</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch72.html">72. stat 構造体</a></span></dt></dl></dd><dt><span class="part"><a href="pt06.html">VI. mmap</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch73.html">73. mmap の使い方</a></span></dt><dt><span class="chapter"><a href="ch74.html">74. マルチタスクで使えると共有メモリーオブジェクト</a></span></dt><dt><span class="chapter"><a href="ch75.html">75. fork()</a></span></dt><dd><dl><dt><span class="section"><a href="ch75s01.html">75.1. fork() を 2 回コールする</a></span></dt><dt><span class="section"><a href="ch75s02.html">75.2. fork() を 3 回コールする</a></span></dt><dt><span class="section"><a href="ch75s03.html">75.3. fork() を 4 回コールする</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch76.html">76. fstat 関数を使ってファイルサイズを指定する場合</a></span></dt><dt><span class="chapter"><a href="ch77.html">77. MAP_PRIVATE の Copy-On-Write</a></span></dt><dd><dl><dt><span class="section"><a href="ch77s01.html">77.1. fork() で MAP_PRIVATE の Copy-On-Write を検証</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch78.html">78. MAP_ANONYMOUS</a></span></dt><dt><span class="chapter"><a href="ch79.html">79. アノニマスマッピング</a></span></dt><dt><span class="chapter"><a href="ch80.html">80. fork() でプライベートファイルマッピングのチェック</a></span></dt><dt><span class="chapter"><a href="ch81.html">81. fork() でプライベートアノニマスマッピングをチェック</a></span></dt><dt><span class="chapter"><a href="ch82.html">82. fork() で共有ファイルマッピングをチェック</a></span></dt><dt><span class="chapter"><a href="ch83.html">83. fork() で共有アノニマスマッピングをチェック</a></span></dt><dt><span class="chapter"><a href="ch84.html">84. /dev/zero</a></span></dt></dl></dd><dt><span class="part"><a href="pt07.html">VII. （汎用ではない）カスタムアロケーターの設計</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch85.html">85. アロケーターに必要な最低限の関数・オーバーロード・テンプレート</a></span></dt><dt><span class="chapter"><a href="ch86.html">86. std::allocator を使うだけのリファレンスアロケーター</a></span></dt><dd><dl><dt><span class="section"><a href="ch86s01.html">86.1. std::allocator を模したカスタムアロケーター</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="pt08.html">VIII. スマートポインターで使えるデリーター</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch87.html">87. スマートポインターの実装</a></span></dt></dl></dd><dt><span class="part"><a href="pt09.html">IX. スタック領域に割り当てるアロケーター</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch88.html">88. 配列内のアドレスの走査</a></span></dt><dd><dl><dt><span class="section"><a href="ch88s01.html">88.1. スタックアロケーター（可変長のリクエストサイズに対応、難易度高いのでスキップ推奨）</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch89.html">89. ヒープへのフォールバック付きスタックアロケーター</a></span></dt><dt><span class="chapter"><a href="ch90.html">90. コードをシンプルにする（内部バッファーのアドレスかのチェック）</a></span></dt></dl></dd><dt><span class="part"><a href="pt10.html">X. ヒープ領域のアドレスに割り当て</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch91.html">91. ヒープ領域のアドレス</a></span></dt><dt><span class="chapter"><a href="ch92.html">92. malloc を使ってヒープに割り当て</a></span></dt><dt><span class="chapter"><a href="ch93.html">93. カスタムヒープアロケーター</a></span></dt><dt><span class="chapter"><a href="ch94.html">94. static オブジェクトはヒープっぽい領域に割り当てられるはず？</a></span></dt><dt><span class="chapter"><a href="ch95.html">95. アロケーターをスタティックメンバーにするとどうなるのか？</a></span></dt></dl></dd><dt><span class="part"><a href="pt11.html">XI. アロケーターをセレクターで切り替え</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch96.html">96. アロケータークラス内での複数の割り当て方針を切り替え</a></span></dt><dd><dl><dt><span class="section"><a href="ch96s01.html">96.1. 複数のアロケーターインスタンスを切り替え</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="pt12.html">XII. C++ カスタムアロケーターの STL サポート（実験）</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch97.html">97. C++ カスタムスタックアロケーターの用語の復習</a></span></dt><dt><span class="chapter"><a href="ch98.html">98. STL コンテナのサポート ( new / delete )</a></span></dt><dt><span class="chapter"><a href="ch99.html">99. STL サポートの適用対象</a></span></dt><dt><span class="chapter"><a href="ch100.html">100. STL コンテナ側のメモリー割り当て要件</a></span></dt><dt><span class="chapter"><a href="ch101.html">101. sizeof を使った割り当てサイズの算出によるスタックアロケーター実装</a></span></dt></dl></dd><dt><span class="part"><a href="pt13.html">XIII. mmap() を使ったカスタムアロケーター</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch102.html">102. ユーザーによるオブジェクト管理を前提にするカスタムページアロケーター</a></span></dt><dt><span class="chapter"><a href="ch103.html">103. カスタムアロケーターによるブロック管理</a></span></dt></dl></dd><dt><span class="part"><a href="pt14.html">XIV. （おまけ）アロケーターのポリモーフィズム</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch104.html">104. メモリーリソースクラス</a></span></dt><dt><span class="chapter"><a href="ch105.html">105. std::experimental::pmr::memory_resource ( C++17 )</a></span></dt><dd><dl><dt><span class="section"><a href="ch105s01.html">105.1. memory_resource でアラインメントの実装（非実用的な実験です）</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch106.html">106. ポリモーフィックアロケーター</a></span></dt><dt><span class="chapter"><a href="ch107.html">107. std::pmr::polymorphic_allocator ( C++17 )</a></span></dt><dt><span class="chapter"><a href="ch108.html">108. std::experimental::pmr::vector コンテナ ( C++17 )</a></span></dt><dt><span class="chapter"><a href="ch109.html">109. std::pmr::polymorphic_allocator の動作チェック</a></span></dt><dd><dl><dt><span class="section"><a href="ch109s01.html">109.1. ポリモーフィックアロケーターの実装</a></span></dt></dl></dd></dl></dd></dl></div><div class="list-of-figures"><p><strong>図の一覧</strong></p><dl><dt>30.1. <a href="ch30.html#idm1253">メインアリーナ（main_arena）</a></dt><dt>30.2. <a href="ch30.html#idm1266">スレッドアリーナ</a></dt><dt>32.1. <a href="ch32.html#idm1345">割り当て済みチャンク（allocated chunk）</a></dt><dt>32.2. <a href="ch32.html#idm1372">割り当て済みチャンクの内部（allocated chunk）</a></dt><dt>32.3. <a href="ch32.html#idm1382">フリーチャンク（free chunk）</a></dt><dt>32.4. <a href="ch32.html#idm1392">フリーチャンクの内部（small free chunk、大きめでない場合）</a></dt><dt>39.1. <a href="ch39.html#idm2278">Unsorted/Small/Large Bins</a></dt><dt>39.2. <a href="ch39.html#idm2306">Large Bins</a></dt><dt>68.1. <a href="ch68.html#idm3396">一段ページテーブル構成</a></dt><dt>68.2. <a href="ch68.html#idm3403">二段ページテーブル構成</a></dt><dt>68.3. <a href="ch68.html#idm3412">Linux 三段ページテーブル（Linux 2.6.11以前）</a></dt></dl></div><div class="list-of-tables"><p><strong>表の一覧</strong></p><dl><dt>19.1. <a href="ch19.html#idm558">mode</a></dt><dt>35.1. <a href="ch35s01.html#idm1539">fastbin_index(sz) の結果</a></dt><dt>37.1. <a href="ch37s01.html#idm1783">64 バイト間隔のインデックス</a></dt><dt>37.2. <a href="ch37s01.html#idm1838">512 バイト間隔のインデックス</a></dt><dt>37.3. <a href="ch37s01.html#idm1927">4096 バイト間隔のインデックス</a></dt><dt>37.4. <a href="ch37s01.html#idm1981">32768 バイト間隔のインデックス</a></dt><dt>37.5. <a href="ch37s01.html#idm2016">262144 バイト間隔のインデックス</a></dt><dt>73.1. <a href="ch73.html#idm3751">メモリー保護（ prot ）</a></dt></dl></div>

<p>Copyright 2018-2019, by Masaki Komatsu</p>
</wrapper></body></html>