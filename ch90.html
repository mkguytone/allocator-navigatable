<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>第90章 コードをシンプルにする（内部バッファーのアドレスかのチェック）</title><link rel="stylesheet" type="text/css" href="index.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Linux で C/C++ の足固め： Linux の メモリー/ファイル/mmap と C++ アロケーター" /><link rel="up" href="pt09.html" title="パート IX. スタック領域に割り当てるアロケーター" /><link rel="prev" href="ch89.html" title="第89章 ヒープへのフォールバック付きスタックアロケーター" /><link rel="next" href="pt10.html" title="パート X. ヒープ領域のアドレスに割り当て" /><script xmlns="" type="text/javascript" src="prettify/prettify.js"></script><link xmlns="" rel="stylesheet" type="text/css" href="prettify/skins/sons-of-obsidian.css" /><script xmlns="">
    window.addEventListener("load", function() {
      PR.prettyPrint();
	  });	
	</script><script xmlns="" type="text/javascript" src="script/head.js"></script><html:meta xmlns:html="http://www.w3.org/1999/xhtml" name="viewport" content="width=320, initial-scale=1"></html:meta></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ch89.html">戻る</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="pt10.html">次へ</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="_コードをシンプルにする_内部バッファーのアドレスかのチェック"></a>第90章 コードをシンプルにする（内部バッファーのアドレスかのチェック）</h2></div></div></div><p>　スタック領域にメモリーを解放する場合は、ポインターが内部バッファーにあるかのチェックが必要な場合があります。</p><p>　例えば以下のようなケースですかね。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
定義したスタック領域のサイズが足りない時にヒープ領域にフォールバックする
</li><li class="listitem">
STLへのアロケーターを作ったリザーブ（予約）したアドレス領域を超えた割当やアクセスが定義されていない
</li></ul></div><p>　前の項目の例では、力技で乗り切った部分がありましたが、実際</p><p>　この基準にあうのであれば、アドレス領域がスタック領域内で定義した内部バッファーにアドレスがあるかチェックするようにしたほうが良いです。</p><p>　さらにフォールバックを行うには std::allocator&lt;T&gt; を使えるようにしたいです。</p><p>　内部バッファーのアドレスかのチェックは、かなり定型化しているのですが、以下のようになるかと思います。</p><pre xmlns="" class="prettyprint">147   bool internal_buffer(const_pointer p) const
148   {
149     return ((const_pointer)M_begin_ &lt;= p &amp;&amp; p &lt;= (const_pointer)M_end_);
150   }</pre><p>　この internal_buffer() 関数がやってるのはポインター p が M_begin_ と M_end_ の範囲内にあるかというチェックです。</p><p>　そして、もしこの internal_buffer() の返す値が偽ならば、 std::allocator&lt;T&gt; へフォールバックするというのが一般的な実装方法かと思いまする。</p><p>　ではサンプルコードを見てみましょう。</p><p><strong>main.cpp. </strong>
</p><pre xmlns="" class="prettyprint">  1 #include &lt;memory&gt;
  2 #include &lt;vector&gt;
  3 #include &lt;iostream&gt;
  4 #include &lt;cassert&gt;
  5 #include &lt;cstddef&gt;
  6 #include &lt;map&gt;
  7
  8 template&lt;typename T, std::size_t N, typename Allocator = std::allocator&lt;T&gt;&gt;
  9 class stack_allocator
 10 {
 11 public:
 12   typedef typename std::allocator_traits&lt;Allocator&gt;::value_type value_type;
 13   typedef typename std::allocator_traits&lt;Allocator&gt;::pointer pointer;
 14   typedef typename std::allocator_traits&lt;Allocator&gt;::const_pointer const_pointer;
 15   typedef typename std::allocator_traits&lt;Allocator&gt;::size_type size_type;
 16   typedef typename std::allocator_traits&lt;Allocator&gt;::difference_type difference_type;
 17   typedef typename std::allocator_traits&lt;Allocator&gt;::void_pointer void_pointer;
 18   typedef typename std::allocator_traits&lt;Allocator&gt;::const_void_pointer const_void_pointer;
 19   typedef typename Allocator::reference reference;
 20   typedef typename Allocator::const_reference const_reference;
 21
 22   typedef std::map&lt;void*,size_t&gt; size_map_t;
 23   typedef std::map&lt;size_t,std::vector&lt;void*&gt;&gt; free_list_t;
 24   typedef std::byte byte;
 25
 26   typedef Allocator allocator_type;
 27
 28   explicit stack_allocator(const allocator_type&amp; alloc = allocator_type())
 29     : M_allocator_(alloc),
 30     M_block_size_(sizeof(T) &lt; 8 ? sizeof(long long) : sizeof(T)),
 31     M_max_objects_(N),
 32     M_begin_(M_buffer_),
 33     M_end_(M_buffer_+M_block_size_*M_max_objects_),
 34     M_stack_pointer_(M_buffer_)
 35   {}
 36
 37   template&lt;typename U&gt;
 38   stack_allocator(const stack_allocator&lt;U,N,Allocator&gt;&amp; other)
 39     : M_allocator_(other.M_allocator_),
 40     M_block_size_(sizeof(T) &lt; 8 ? sizeof(long long) : sizeof(T)),
 41     M_max_objects_(N),
 42     M_begin_(other.M_begin_),
 43     M_end_(other.M_end_),
 44     M_stack_pointer_(other.M_stack_pointer_)
 45   {}
 46
 47   template&lt;typename U&gt;
 48   struct rebind
 49   {
 50     typedef stack_allocator&lt;U,N,allocator_type&gt; other;
 51   };
 52
 53   pointer allocate(size_type n, const_void_pointer hint = const_void_pointer())
 54   {
 55     auto&amp; free_chunks = M_free_list_[n * M_block_size_];
 56     if(!free_chunks.empty()){
 57       std::cout &lt;&lt; "reuse pointer" &lt;&lt; '\n';
 58       auto old_block = static_cast&lt;T*&gt;(free_chunks.back());
 59       free_chunks.pop_back();
 60       return old_block;
 61     } else if(M_end_ - M_stack_pointer_ &gt;= n * M_block_size_) {
 62       std::cout &lt;&lt; "allocate on the stack" &lt;&lt; '\n';
 63       pointer new_block = reinterpret_cast&lt;pointer&gt;(M_stack_pointer_);
 64       M_stack_pointer_ += n * M_block_size_;
 65       M_size_map_[new_block] = n * M_block_size_;
 66       return new_block;
 67     } else {
 68       std::cout &lt;&lt; "allocate on the heap" &lt;&lt; '\n';
 69       return M_allocator_.allocate(n,hint);
 70     }
 71   }
 72
 73   void deallocate(pointer p, size_type n)
 74   {
 75     auto chunk_size = M_size_map_[(void*)p];
 76     if(internal_buffer(p) || chunk_size != 0)
 77     {
 78       M_free_list_[chunk_size].push_back((void*)p);
 79       std::cout &lt;&lt; "deallocate on the stack" &lt;&lt; '\n';
 80     } else {
 81       M_allocator_.deallocate(p,n);
 82       std::cout &lt;&lt; "deallocate on the heap" &lt;&lt; '\n';
 83     }
 84   }
 85
 86   size_type max_size() const noexcept
 87   {
 88     return (size_type)(~0) / sizeof(T);
 89   }
 90
 91   template&lt;typename U, typename... Args&gt;
 92   void construct(U* p, Args&amp;&amp;... args)
 93   {
 94     if(internal_buffer(p)) {
 95       std::cout &lt;&lt; "internal buffer construct" &lt;&lt; '\n';
 96       ::new ((void*)p) T(args...);
 97     } else {
 98       std::cout &lt;&lt; "construct on the heap" &lt;&lt; '\n';
 99       M_allocator_.construct(p,std::forward&lt;Args&gt;(args)...);
100     }
101   }
102
103   template&lt;typename U&gt;
104   void destroy(U* p)
105   {
106     if(internal_buffer(p)) {
107       std::cout &lt;&lt; "internal buffer destroy" &lt;&lt; '\n';
108       p-&gt;~T();
109     } else {
110       std::cout &lt;&lt; "destroy the heap object" &lt;&lt; '\n';
111       M_allocator_.destroy(p);
112     }
113   }
114
115   pointer address(reference x) const noexcept
116   {
117     if(internal_buffer(std::addressof(x)))
118     {
119       return std::addressof(x);
120     }
121
122     return M_allocator_.address(x);
123   }
124
125   const_pointer address(const_reference x) const noexcept
126   {
127     if(internal_buffer(std::addressof(x)))
128     {
129       return addressof(x);
130     }
131
132     return M_allocator_.address(x);
133   }
134
135   pointer buffer() const noexcept
136   {
137     return M_begin_;
138   }
139
140   constexpr static size_type capacity()
141   {
142     return N;
143   }
144
145 private:
146
147   bool internal_buffer(const_pointer p) const
148   {
149     return ((const_pointer)M_begin_ &lt;= p &amp;&amp; p &lt;= (const_pointer)M_end_);
150   }
151
152   allocator_type M_allocator_;
153   size_map_t M_size_map_;
154   free_list_t M_free_list_;
155   byte M_buffer_[N*(sizeof(T) &lt; 8 ? sizeof(long long) : sizeof(T))];
156   size_type M_block_size_;
157   size_type M_max_objects_;
158
159   byte* M_begin_;
160   byte* M_end_;
161   byte* M_stack_pointer_;
162 };
163
164 template&lt;typename T1, std::size_t N, typename Allocator, typename T2&gt;
165 bool operator==(const stack_allocator&lt;T1,N,Allocator&gt;&amp; lhs, const stack_allocator&lt;T2,N,Allocator&gt;&amp; rhs) noexcept
166 {
167   return lhs.buffer() == rhs.buffer();
168 }
169
170 template&lt;typename T1, std::size_t N, typename Allocator, typename T2&gt;
171 bool operator!=(const stack_allocator&lt;T1,N,Allocator&gt;&amp; lhs, const stack_allocator&lt;T2,N,Allocator&gt;&amp; rhs) noexcept
172 {
173   return !(lhs == rhs);
174 }
175
176 const std::size_t stack_size = 8;
177
178 int main()
179 {
180   typedef stack_allocator&lt;int,stack_size&gt; allocator_type;
181   allocator_type alloc;
182   int* t = alloc.allocate(1);
183   alloc.construct(t,100);
184   std::cout &lt;&lt; *t &lt;&lt; '\n';
185   alloc.destroy(t);
186   alloc.deallocate(t,1);
187
188   int* data[15];
189
190   for(int i = 0; i &lt; 5; ++i){
191     data[i] = alloc.allocate(1);
192   }
193   for(int i = 1; i &lt; 5; ++i){
194     alloc.deallocate(data[i],1);
195   }
196
197   for(int i = 5; i &lt; 15; ++i){
198     data[i] = alloc.allocate(1);
199   }
200
201   for(int i = 5; i &lt; 15; ++i){
202     alloc.deallocate(data[i],1);
203   }
204
205   alloc.deallocate(data[0],1);
206
207   return 0;
208 }</pre><p>
</p><p><strong>ビルドと実行結果. </strong>
</p><pre xmlns="" class="prettyprint">$ g++ main.cpp -std=c++17
$ ./a.out
allocate on the stack
internal buffer construct
100
internal buffer destroy
deallocate on the stack
reuse pointer
allocate on the stack
allocate on the stack
allocate on the stack
allocate on the stack
deallocate on the stack
deallocate on the stack
deallocate on the stack
deallocate on the stack
reuse pointer
reuse pointer
reuse pointer
reuse pointer
allocate on the stack
allocate on the stack
allocate on the stack
allocate on the heap
allocate on the heap
allocate on the heap
deallocate on the stack
deallocate on the stack
deallocate on the stack
deallocate on the stack
deallocate on the stack
deallocate on the stack
deallocate on the stack
deallocate on the heap
deallocate on the heap
deallocate on the heap
deallocate on the stack</pre><p>
</p><p>　まずはクラス内のメンバー型とメンバーオブジェクト・変数から見ていきましょう。</p><pre xmlns="" class="prettyprint">  8 template&lt;typename T, std::size_t N, typename Allocator = std::allocator&lt;T&gt;&gt;
  9 class stack_allocator
 10 {
 11 public:
 12   typedef typename std::allocator_traits&lt;Allocator&gt;::value_type value_type;
 13   typedef typename std::allocator_traits&lt;Allocator&gt;::pointer pointer;
 14   typedef typename std::allocator_traits&lt;Allocator&gt;::const_pointer const_pointer;
 15   typedef typename std::allocator_traits&lt;Allocator&gt;::size_type size_type;
 16   typedef typename std::allocator_traits&lt;Allocator&gt;::difference_type difference_type;
 17   typedef typename std::allocator_traits&lt;Allocator&gt;::void_pointer void_pointer;
 18   typedef typename std::allocator_traits&lt;Allocator&gt;::const_void_pointer const_void_pointer;
 19   typedef typename Allocator::reference reference;
 20   typedef typename Allocator::const_reference const_reference;
 21
 22   typedef std::map&lt;void*,size_t&gt; size_map_t;
 23   typedef std::map&lt;size_t,std::vector&lt;void*&gt;&gt; free_list_t;
 24   typedef std::byte byte;
 25
 26   typedef Allocator allocator_type;

 //   中略

152   allocator_type M_allocator_;
153   size_map_t M_size_map_;
154   free_list_t M_free_list_;
155   byte M_buffer_[N*(sizeof(T) &lt; 8 ? sizeof(long long) : sizeof(T))];
156   size_type M_block_size_;
157   size_type M_max_objects_;
158
159   byte* M_begin_;
160   byte* M_end_;
161   byte* M_stack_pointer_;
162 };</pre><p>　この中で内部バッファーの範囲を定義するのは M_begin_ と M_end_ です。</p><p>　後は M_buffer_ がベースとなるデータを保管してくれるスタック領域のバッファーです。</p><pre xmlns="" class="prettyprint"> 28   explicit stack_allocator(const allocator_type&amp; alloc = allocator_type())
 29     : M_allocator_(alloc),
 30     M_block_size_(sizeof(T) &lt; 8 ? sizeof(long long) : sizeof(T)),
 31     M_max_objects_(N),
 32     M_begin_(M_buffer_),
 33     M_end_(M_buffer_+M_block_size_*M_max_objects_),
 34     M_stack_pointer_(M_buffer_)
 35   {}</pre><p>　コンストラクターでは M_begin_ を M_buffer_ に設定しています。</p><p>　まあ M_buffer_ はスタックバッファーの開始アドレスを指すポインターなので、これが開始点となるのはご依存ないですよね？</p><p>　次に M_end_ には 「 M_buffer_+M_block_size_*M_max_objects_ 」が代入されます。</p><p>　まあこれも M_buffer_ に M_buffer_ のバイトサイズを加算しているので、終端を指すポインターになるだけです。</p><p>　この内部バッファーチェックを使っている箇所が以下の deallocate() 関数です。</p><pre xmlns="" class="prettyprint"> 73   void deallocate(pointer p, size_type n)
 74   {
 75     auto chunk_size = M_size_map_[(void*)p];
 76     if(internal_buffer(p) || chunk_size != 0)
 77     {
 78       M_free_list_[chunk_size].push_back((void*)p);
 79       std::cout &lt;&lt; "deallocate on the stack" &lt;&lt; '\n';
 80     } else {
 81       M_allocator_.deallocate(p,n);
 82       std::cout &lt;&lt; "deallocate on the heap" &lt;&lt; '\n';
 83     }
 84   }</pre><p>　p が内部バッファーにないか、フリーチャンクが存在しない場合は標準アロケーターにフォールバックしていますね。</p><p>　まあ、こんな感じで内部バッファーのチェックを行うと良いかと思います。</p><p>　筆者は時間が無かったのと、説明するときのコードはキレイよりベタな方が良さそうという、その場のノリで、あまりチェックはしていないです。</p><p>　まあそれと、書くのも時間かかりますんでご理解賜りたいものです…　(´・ω・｀)</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch89.html">戻る</a> </td><td width="20%" align="center"><a accesskey="u" href="pt09.html">上に戻る</a></td><td width="40%" align="right"> <a accesskey="n" href="pt10.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div><wrapper xmlns=""><p>Copyright 2018-2019, by Masaki Komatsu</p>

<div class="toc"><p><strong>目次</strong></p><dl class="toc"><dt><span class="preface"><a href="pr01.html">序文</a></span></dt><dd><dl><dt><span class="section"><a href="pr01s01.html">1. Linux カーネルを学ぶ意義</a></span></dt><dt><span class="section"><a href="pr01s02.html">2. C++ カスタムアロケーターを作る意義</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch01.html">1. 対象となる読者</a></span></dt><dt><span class="chapter"><a href="ch02.html">2. 前提知識</a></span></dt><dt><span class="chapter"><a href="ch03.html">3. 開発環境</a></span></dt><dd><dl><dt><span class="section"><a href="ch03s01.html">3.1. Linux カーネルのバージョンを揃える</a></span></dt></dl></dd><dt><span class="part"><a href="pt01.html">I. Linux と POSIX C</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch04.html">4. パイプとリダイレクトのまとめ</a></span></dt><dt><span class="chapter"><a href="ch05.html">5. echo コマンド</a></span></dt><dt><span class="chapter"><a href="ch06.html">6. シェルの確認</a></span></dt><dt><span class="chapter"><a href="ch07.html">7. /dev ディレクトリー</a></span></dt><dd><dl><dt><span class="section"><a href="ch07s01.html">7.1. echo のリダイレクト</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch08.html">8. アペンド</a></span></dt><dt><span class="chapter"><a href="ch09.html">9. リダイレクトのファイル記述子</a></span></dt><dt><span class="chapter"><a href="ch10.html">10. ファイル記述子間のリダイレクト</a></span></dt><dt><span class="chapter"><a href="ch11.html">11. ファイル記述子リダイレクトのまとめ</a></span></dt><dt><span class="chapter"><a href="ch12.html">12. exec (bash)</a></span></dt><dt><span class="chapter"><a href="ch13.html">13. ファイル記述子を閉じる</a></span></dt><dt><span class="chapter"><a href="ch14.html">14. 読み書きファイル記述子</a></span></dt><dt><span class="chapter"><a href="ch15.html">15. /proc ディレクトリー</a></span></dt><dt><span class="chapter"><a href="ch16.html">16. /dev/shm ディレクトリー</a></span></dt></dl></dd><dt><span class="part"><a href="pt02.html">II. Linux (POSIX) のファイル入出力</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch17.html">17. system 関数</a></span></dt><dt><span class="chapter"><a href="ch18.html">18. fprintf 関数</a></span></dt><dt><span class="chapter"><a href="ch19.html">19. open / dprintf 関数</a></span></dt><dt><span class="chapter"><a href="ch20.html">20. read() / write() 関数</a></span></dt><dd><dl><dt><span class="section"><a href="ch20s01.html">20.1. 文字列をヒープにコピー</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch21.html">21. lseek()</a></span></dt><dt><span class="chapter"><a href="ch22.html">22. fopen / fread / fwrite / fclose 関数</a></span></dt></dl></dd><dt><span class="part"><a href="pt03.html">III. Linux でメモリー割り当て</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch23.html">23. 32 ビットプロセスのレイアウト</a></span></dt><dt><span class="chapter"><a href="ch24.html">24. malloc (cstdlib)</a></span></dt><dt><span class="chapter"><a href="ch25.html">25. malloc を strace で検証してみる</a></span></dt><dd><dl><dt><span class="section"><a href="ch25s01.html">25.1. ASLR と共有オブジェクト</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch26.html">26. MALLOC(3) Linux プログラマーマニュアル</a></span></dt><dt><span class="chapter"><a href="ch27.html">27. brk / sbrk (unistd.h)</a></span></dt><dd><dl><dt><span class="section"><a href="ch27s01.html">27.1. gdb で sbrk() の解析</a></span></dt><dt><span class="section"><a href="ch27s02.html">27.2. strace によって brk() / malloc() のコールをチェック</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="pt04.html">IV. glibc から malloc() の基本構造を理解してみる</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch28.html">28. malloc() の内部実装</a></span></dt><dt><span class="chapter"><a href="ch29.html">29. アリーナによるマルチスレッド対応</a></span></dt><dt><span class="chapter"><a href="ch30.html">30. アリーナオブジェクト（ main_arena / malloc_state ）</a></span></dt><dt><span class="chapter"><a href="ch31.html">31. ヒープのヘッダーオブジェクト（ heap_info )</a></span></dt><dt><span class="chapter"><a href="ch32.html">32. チャンク（ malloc_chunk ）</a></span></dt><dt><span class="chapter"><a href="ch33.html">33. 最少チャンクサイズと最少割り当てサイズ</a></span></dt><dt><span class="chapter"><a href="ch34.html">34. malloc_par</a></span></dt><dt><span class="chapter"><a href="ch35.html">35. top チャンク</a></span></dt><dd><dl><dt><span class="section"><a href="ch35s01.html">35.1. ビン</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch36.html">36. 未整理ビン / スモールビン / ラージビン</a></span></dt><dt><span class="chapter"><a href="ch37.html">37. ビンのインデックスの計算</a></span></dt><dd><dl><dt><span class="section"><a href="ch37s01.html">37.1. 32 ビットアーキテクチャのビン</a></span></dt><dt><span class="section"><a href="ch37s02.html">37.2. 64 ビットアーキテクチャのビン</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch38.html">38. ビン・インデックスのまとめ</a></span></dt><dt><span class="chapter"><a href="ch39.html">39. ビンのチャンク連結</a></span></dt><dt><span class="chapter"><a href="ch40.html">40. ビンの初期化</a></span></dt><dt><span class="chapter"><a href="ch41.html">41. 未整理チャンク（ Unsorted Chunk ）のマクロ</a></span></dt><dt><span class="chapter"><a href="ch42.html">42. トップチャンク（ Top Chunk ）のマクロ</a></span></dt><dt><span class="chapter"><a href="ch43.html">43. Binmap のマクロ</a></span></dt><dt><span class="chapter"><a href="ch44.html">44. tcache</a></span></dt><dt><span class="chapter"><a href="ch45.html">45. malloc() フリーチャンクの挙動</a></span></dt><dt><span class="chapter"><a href="ch46.html">46. malloc.c の内部マクロ</a></span></dt><dd><dl><dt><span class="section"><a href="ch46s01.html">46.1. チャンクを取り扱えるマクロ</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch47.html">47. ファーストビンの解放</a></span></dt><dt><span class="chapter"><a href="ch48.html">48. malloc.c の内部関数</a></span></dt><dt><span class="chapter"><a href="ch49.html">49. malloc() の実装</a></span></dt><dd><dl><dt><span class="section"><a href="ch49s01.html">49.1. _int_malloc() 関数</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch50.html">50. free() の実装</a></span></dt><dt><span class="chapter"><a href="ch51.html">51. calloc()</a></span></dt><dt><span class="chapter"><a href="ch52.html">52. realloc()</a></span></dt><dt><span class="chapter"><a href="ch53.html">53. alloca() 関数</a></span></dt><dd><dl><dt><span class="section"><a href="ch53s01.html">53.1. alloca() の使用法</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch54.html">54. posix_memalign() / aligned_alloc()</a></span></dt><dd><dl><dt><span class="section"><a href="ch54s01.html">54.1. glibc-2.7 の内部実装</a></span></dt><dt><span class="section"><a href="ch54s02.html">54.2. アラインメントの仕組み</a></span></dt><dt><span class="section"><a href="ch54s03.html">54.3. アラインメントの最少サイズ</a></span></dt><dt><span class="section"><a href="ch54s04.html">54.4. 大きめのアラインメント</a></span></dt><dt><span class="section"><a href="ch54s05.html">54.5. 複数のアラインメントでの検証</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch55.html">55. std::launder ( C++17 )</a></span></dt><dt><span class="chapter"><a href="ch56.html">56. std::aligned_storage ( C++11 )</a></span></dt><dt><span class="chapter"><a href="ch57.html">57. std::align ( C++11 )</a></span></dt><dt><span class="chapter"><a href="ch58.html">58. std::aligned_alloc ( C++17 )</a></span></dt></dl></dd><dt><span class="part"><a href="pt05.html">V. Linux カーネルのメモリーとファイルシステム</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch59.html">59. Linux の仮想メモリーエリア・メモリー記述子</a></span></dt><dt><span class="chapter"><a href="ch60.html">60. メモリー記述子（ mm_struct ）</a></span></dt><dt><span class="chapter"><a href="ch61.html">61. 仮想メモリー領域（ vm_area_struct ）</a></span></dt><dt><span class="chapter"><a href="ch62.html">62. ページ記述子（ struct page ）</a></span></dt><dt><span class="chapter"><a href="ch63.html">63. ページとブロック</a></span></dt><dt><span class="chapter"><a href="ch64.html">64. バッファー ( buffer_head )</a></span></dt><dt><span class="chapter"><a href="ch65.html">65. ブロック I/O ( bio )</a></span></dt><dt><span class="chapter"><a href="ch66.html">66. ページのキャッシュ</a></span></dt><dt><span class="chapter"><a href="ch67.html">67. スラブレイヤー・スラブアロケーター</a></span></dt><dt><span class="chapter"><a href="ch68.html">68. ファイルとメモリーのマッピング (mmap)</a></span></dt><dt><span class="chapter"><a href="ch69.html">69. ページとハードウェア</a></span></dt><dt><span class="chapter"><a href="ch70.html">70. ページキャッシュ ( struct address_space )</a></span></dt><dt><span class="chapter"><a href="ch71.html">71. Linux のファイルシステム</a></span></dt><dd><dl><dt><span class="section"><a href="ch71s01.html">71.1. カーネルヘッダー ( /usr/src/ )</a></span></dt><dt><span class="section"><a href="ch71s02.html">71.2. カーネルソースのアーカイブ</a></span></dt><dt><span class="section"><a href="ch71s03.html">71.3. super_block (カーネル)</a></span></dt><dt><span class="section"><a href="ch71s04.html">71.4. inode (カーネル)</a></span></dt><dt><span class="section"><a href="ch71s05.html">71.5. dentry (カーネル)</a></span></dt><dt><span class="section"><a href="ch71s06.html">71.6. file (カーネル)</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch72.html">72. stat 構造体</a></span></dt></dl></dd><dt><span class="part"><a href="pt06.html">VI. mmap</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch73.html">73. mmap の使い方</a></span></dt><dt><span class="chapter"><a href="ch74.html">74. マルチタスクで使えると共有メモリーオブジェクト</a></span></dt><dt><span class="chapter"><a href="ch75.html">75. fork()</a></span></dt><dd><dl><dt><span class="section"><a href="ch75s01.html">75.1. fork() を 2 回コールする</a></span></dt><dt><span class="section"><a href="ch75s02.html">75.2. fork() を 3 回コールする</a></span></dt><dt><span class="section"><a href="ch75s03.html">75.3. fork() を 4 回コールする</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch76.html">76. fstat 関数を使ってファイルサイズを指定する場合</a></span></dt><dt><span class="chapter"><a href="ch77.html">77. MAP_PRIVATE の Copy-On-Write</a></span></dt><dd><dl><dt><span class="section"><a href="ch77s01.html">77.1. fork() で MAP_PRIVATE の Copy-On-Write を検証</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch78.html">78. MAP_ANONYMOUS</a></span></dt><dt><span class="chapter"><a href="ch79.html">79. アノニマスマッピング</a></span></dt><dt><span class="chapter"><a href="ch80.html">80. fork() でプライベートファイルマッピングのチェック</a></span></dt><dt><span class="chapter"><a href="ch81.html">81. fork() でプライベートアノニマスマッピングをチェック</a></span></dt><dt><span class="chapter"><a href="ch82.html">82. fork() で共有ファイルマッピングをチェック</a></span></dt><dt><span class="chapter"><a href="ch83.html">83. fork() で共有アノニマスマッピングをチェック</a></span></dt><dt><span class="chapter"><a href="ch84.html">84. /dev/zero</a></span></dt></dl></dd><dt><span class="part"><a href="pt07.html">VII. （汎用ではない）カスタムアロケーターの設計</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch85.html">85. アロケーターに必要な最低限の関数・オーバーロード・テンプレート</a></span></dt><dt><span class="chapter"><a href="ch86.html">86. std::allocator を使うだけのリファレンスアロケーター</a></span></dt><dd><dl><dt><span class="section"><a href="ch86s01.html">86.1. std::allocator を模したカスタムアロケーター</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="pt08.html">VIII. スマートポインターで使えるデリーター</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch87.html">87. スマートポインターの実装</a></span></dt></dl></dd><dt><span class="part"><a href="pt09.html">IX. スタック領域に割り当てるアロケーター</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch88.html">88. 配列内のアドレスの走査</a></span></dt><dd><dl><dt><span class="section"><a href="ch88s01.html">88.1. スタックアロケーター（可変長のリクエストサイズに対応、難易度高いのでスキップ推奨）</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch89.html">89. ヒープへのフォールバック付きスタックアロケーター</a></span></dt><dt><span class="chapter"><a href="ch90.html">90. コードをシンプルにする（内部バッファーのアドレスかのチェック）</a></span></dt></dl></dd><dt><span class="part"><a href="pt10.html">X. ヒープ領域のアドレスに割り当て</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch91.html">91. ヒープ領域のアドレス</a></span></dt><dt><span class="chapter"><a href="ch92.html">92. malloc を使ってヒープに割り当て</a></span></dt><dt><span class="chapter"><a href="ch93.html">93. カスタムヒープアロケーター</a></span></dt><dt><span class="chapter"><a href="ch94.html">94. static オブジェクトはヒープっぽい領域に割り当てられるはず？</a></span></dt><dt><span class="chapter"><a href="ch95.html">95. アロケーターをスタティックメンバーにするとどうなるのか？</a></span></dt></dl></dd><dt><span class="part"><a href="pt11.html">XI. アロケーターをセレクターで切り替え</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch96.html">96. アロケータークラス内での複数の割り当て方針を切り替え</a></span></dt><dd><dl><dt><span class="section"><a href="ch96s01.html">96.1. 複数のアロケーターインスタンスを切り替え</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="pt12.html">XII. C++ カスタムアロケーターの STL サポート（実験）</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch97.html">97. C++ カスタムスタックアロケーターの用語の復習</a></span></dt><dt><span class="chapter"><a href="ch98.html">98. STL コンテナのサポート ( new / delete )</a></span></dt><dt><span class="chapter"><a href="ch99.html">99. STL サポートの適用対象</a></span></dt><dt><span class="chapter"><a href="ch100.html">100. STL コンテナ側のメモリー割り当て要件</a></span></dt><dt><span class="chapter"><a href="ch101.html">101. sizeof を使った割り当てサイズの算出によるスタックアロケーター実装</a></span></dt></dl></dd><dt><span class="part"><a href="pt13.html">XIII. mmap() を使ったカスタムアロケーター</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch102.html">102. ユーザーによるオブジェクト管理を前提にするカスタムページアロケーター</a></span></dt><dt><span class="chapter"><a href="ch103.html">103. カスタムアロケーターによるブロック管理</a></span></dt></dl></dd><dt><span class="part"><a href="pt14.html">XIV. （おまけ）アロケーターのポリモーフィズム</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch104.html">104. メモリーリソースクラス</a></span></dt><dt><span class="chapter"><a href="ch105.html">105. std::experimental::pmr::memory_resource ( C++17 )</a></span></dt><dd><dl><dt><span class="section"><a href="ch105s01.html">105.1. memory_resource でアラインメントの実装（非実用的な実験です）</a></span></dt></dl></dd><dt><span class="chapter"><a href="ch106.html">106. ポリモーフィックアロケーター</a></span></dt><dt><span class="chapter"><a href="ch107.html">107. std::pmr::polymorphic_allocator ( C++17 )</a></span></dt><dt><span class="chapter"><a href="ch108.html">108. std::experimental::pmr::vector コンテナ ( C++17 )</a></span></dt><dt><span class="chapter"><a href="ch109.html">109. std::pmr::polymorphic_allocator の動作チェック</a></span></dt><dd><dl><dt><span class="section"><a href="ch109s01.html">109.1. ポリモーフィックアロケーターの実装</a></span></dt></dl></dd></dl></dd></dl></div><div class="list-of-figures"><p><strong>図の一覧</strong></p><dl><dt>30.1. <a href="ch30.html#idm1253">メインアリーナ（main_arena）</a></dt><dt>30.2. <a href="ch30.html#idm1266">スレッドアリーナ</a></dt><dt>32.1. <a href="ch32.html#idm1345">割り当て済みチャンク（allocated chunk）</a></dt><dt>32.2. <a href="ch32.html#idm1372">割り当て済みチャンクの内部（allocated chunk）</a></dt><dt>32.3. <a href="ch32.html#idm1382">フリーチャンク（free chunk）</a></dt><dt>32.4. <a href="ch32.html#idm1392">フリーチャンクの内部（small free chunk、大きめでない場合）</a></dt><dt>39.1. <a href="ch39.html#idm2278">Unsorted/Small/Large Bins</a></dt><dt>39.2. <a href="ch39.html#idm2306">Large Bins</a></dt><dt>68.1. <a href="ch68.html#idm3396">一段ページテーブル構成</a></dt><dt>68.2. <a href="ch68.html#idm3403">二段ページテーブル構成</a></dt><dt>68.3. <a href="ch68.html#idm3412">Linux 三段ページテーブル（Linux 2.6.11以前）</a></dt></dl></div><div class="list-of-tables"><p><strong>表の一覧</strong></p><dl><dt>19.1. <a href="ch19.html#idm558">mode</a></dt><dt>35.1. <a href="ch35s01.html#idm1539">fastbin_index(sz) の結果</a></dt><dt>37.1. <a href="ch37s01.html#idm1783">64 バイト間隔のインデックス</a></dt><dt>37.2. <a href="ch37s01.html#idm1838">512 バイト間隔のインデックス</a></dt><dt>37.3. <a href="ch37s01.html#idm1927">4096 バイト間隔のインデックス</a></dt><dt>37.4. <a href="ch37s01.html#idm1981">32768 バイト間隔のインデックス</a></dt><dt>37.5. <a href="ch37s01.html#idm2016">262144 バイト間隔のインデックス</a></dt><dt>73.1. <a href="ch73.html#idm3751">メモリー保護（ prot ）</a></dt></dl></div>

<p>Copyright 2018-2019, by Masaki Komatsu</p>
</wrapper></body></html>